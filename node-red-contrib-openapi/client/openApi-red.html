
<script type='text/javascript'>
  {
    function render (node) {
      try {
        if (typeof node !== 'object') {
          return
        }
        if (!node.__clone) {
          node.__clone = window.$.extend(true, {}, node)
        }
        new OpenApi_red({
          target: document.getElementById('openApi-red-svelte-container'),
          props: { node: node.__clone }
        })
      } catch (e) {
        console.log(e)
      }
    }
    function update (node) {
      if (node.__clone) {
        const clone = node.__clone
        delete node.__clone
        const defaultKeys = Object.keys(node._def.defaults)
        for (const key of Object.keys(clone)) {
          if (defaultKeys.indexOf(key) === -1) {
            delete clone[key]
          }
        }
        Object.assign(node, clone)
      }
    }
    function revert (node) {
      delete node.__clone
    }
    function noop() { }
    function assign(tar, src) {
      // @ts-ignore
      for (const k in src)
        tar[k] = src[k];
      return tar;
    }
    function run(fn) {
      return fn();
    }
    function blank_object() {
      return Object.create(null);
    }
    function run_all(fns) {
      fns.forEach(run);
    }
    function is_function(thing) {
      return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
      return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
      return Object.keys(obj).length === 0;
    }
    function create_slot(definition, ctx, $$scope, fn) {
      if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
      }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
      return definition[1] && fn
        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
        : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
      if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
          return lets;
        }
        if (typeof lets === 'object') {
          const merged = [];
          const len = Math.max($$scope.dirty.length, lets.length);
          for (let i = 0; i < len; i += 1) {
            merged[i] = $$scope.dirty[i] | lets[i];
          }
          return merged;
        }
        return $$scope.dirty | lets;
      }
      return $$scope.dirty;
    }
    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
      const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
      if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
      }
    }

    function append(target, node) {
      target.appendChild(node);
    }
    function insert(target, node, anchor) {
      target.insertBefore(node, anchor || null);
    }
    function detach(node) {
      node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
      for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
          iterations[i].d(detaching);
      }
    }
    function element(name) {
      return document.createElement(name);
    }
    function text(data) {
      return document.createTextNode(data);
    }
    function space() {
      return text(' ');
    }
    function empty() {
      return text('');
    }
    function listen(node, event, handler, options) {
      node.addEventListener(event, handler, options);
      return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
      if (value == null)
        node.removeAttribute(attribute);
      else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
    }
    function to_number(value) {
      return value === '' ? null : +value;
    }
    function children(element) {
      return Array.from(element.childNodes);
    }
    function set_data(text, data) {
      data = '' + data;
      if (text.wholeText !== data)
        text.data = data;
    }
    function set_input_value(input, value) {
      input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
      node.style.setProperty(key, value, important ? 'important' : '');
    }
    function select_option(select, value) {
      for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        if (option.__value === value) {
          option.selected = true;
          return;
        }
      }
    }
    function select_value(select) {
      const selected_option = select.querySelector(':checked') || select.options[0];
      return selected_option && selected_option.__value;
    }
    function toggle_class(element, name, toggle) {
      element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail) {
      const e = document.createEvent('CustomEvent');
      e.initCustomEvent(type, false, false, detail);
      return e;
    }

    let current_component;
    function set_current_component(component) {
      current_component = component;
    }
    function get_current_component() {
      if (!current_component)
        throw new Error('Function called outside component initialization');
      return current_component;
    }
    function onMount(fn) {
      get_current_component().$$.on_mount.push(fn);
    }
    function createEventDispatcher() {
      const component = get_current_component();
      return (type, detail) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
          // TODO are there situations where events could be dispatched
          // in a server (non-DOM) environment?
          const event = custom_event(type, detail);
          callbacks.slice().forEach(fn => {
            fn.call(component, event);
          });
        }
      };
    }
// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
    function bubble(component, event) {
      const callbacks = component.$$.callbacks[event.type];
      if (callbacks) {
        callbacks.slice().forEach(fn => fn(event));
      }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
      if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
      }
    }
    function add_render_callback(fn) {
      render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
      flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
      if (flushing)
        return;
      flushing = true;
      do {
        // first, call beforeUpdate functions
        // and update components
        for (let i = 0; i < dirty_components.length; i += 1) {
          const component = dirty_components[i];
          set_current_component(component);
          update$1(component.$$);
        }
        set_current_component(null);
        dirty_components.length = 0;
        while (binding_callbacks.length)
          binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
          const callback = render_callbacks[i];
          if (!seen_callbacks.has(callback)) {
            // ...so guard against infinite loops
            seen_callbacks.add(callback);
            callback();
          }
        }
        render_callbacks.length = 0;
      } while (dirty_components.length);
      while (flush_callbacks.length) {
        flush_callbacks.pop()();
      }
      update_scheduled = false;
      flushing = false;
      seen_callbacks.clear();
    }
    function update$1($$) {
      if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
      }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
      outros = {
        r: 0,
        c: [],
        p: outros // parent group
      };
    }
    function check_outros() {
      if (!outros.r) {
        run_all(outros.c);
      }
      outros = outros.p;
    }
    function transition_in(block, local) {
      if (block && block.i) {
        outroing.delete(block);
        block.i(local);
      }
    }
    function transition_out(block, local, detach, callback) {
      if (block && block.o) {
        if (outroing.has(block))
          return;
        outroing.add(block);
        outros.c.push(() => {
          outroing.delete(block);
          if (callback) {
            if (detach)
              block.d(1);
            callback();
          }
        });
        block.o(local);
      }
    }

    function destroy_block(block, lookup) {
      block.d(1);
      lookup.delete(block.key);
    }
    function outro_and_destroy_block(block, lookup) {
      transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
      });
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
      let o = old_blocks.length;
      let n = list.length;
      let i = o;
      const old_indexes = {};
      while (i--)
        old_indexes[old_blocks[i].key] = i;
      const new_blocks = [];
      const new_lookup = new Map();
      const deltas = new Map();
      i = n;
      while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);
        if (!block) {
          block = create_each_block(key, child_ctx);
          block.c();
        }
        else if (dynamic) {
          block.p(child_ctx, dirty);
        }
        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes)
          deltas.set(key, Math.abs(i - old_indexes[key]));
      }
      const will_move = new Set();
      const did_move = new Set();
      function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
      }
      while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
          // do nothing
          next = new_block.first;
          o--;
          n--;
        }
        else if (!new_lookup.has(old_key)) {
          // remove old block
          destroy(old_block, lookup);
          o--;
        }
        else if (!lookup.has(new_key) || will_move.has(new_key)) {
          insert(new_block);
        }
        else if (did_move.has(old_key)) {
          o--;
        }
        else if (deltas.get(new_key) > deltas.get(old_key)) {
          did_move.add(new_key);
          insert(new_block);
        }
        else {
          will_move.add(old_key);
          o--;
        }
      }
      while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key))
          destroy(old_block, lookup);
      }
      while (n)
        insert(new_blocks[n - 1]);
      return new_blocks;
    }

    function bind(component, name, callback) {
      const index = component.$$.props[name];
      if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
      }
    }
    function create_component(block) {
      block && block.c();
    }
    function mount_component(component, target, anchor) {
      const { fragment, on_mount, on_destroy, after_update } = component.$$;
      fragment && fragment.m(target, anchor);
      // onMount happens before the initial afterUpdate
      add_render_callback(() => {
        const new_on_destroy = on_mount.map(run).filter(is_function);
        if (on_destroy) {
          on_destroy.push(...new_on_destroy);
        }
        else {
          // Edge case - component was destroyed immediately,
          // most likely as a result of a binding initialising
          run_all(new_on_destroy);
        }
        component.$$.on_mount = [];
      });
      after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
      const $$ = component.$$;
      if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
      }
    }
    function make_dirty(component, i) {
      if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
      }
      component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
      const parent_component = current_component;
      set_current_component(component);
      const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : []),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false
      };
      let ready = false;
      $$.ctx = instance
        ? instance(component, options.props || {}, (i, ret, ...rest) => {
          const value = rest.length ? rest[0] : ret;
          if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
            if (!$$.skip_bound && $$.bound[i])
              $$.bound[i](value);
            if (ready)
              make_dirty(component, i);
          }
          return ret;
        })
        : [];
      $$.update();
      ready = true;
      run_all($$.before_update);
      // `false` as a special case of no DOM component
      $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
      if (options.target) {
        if (options.hydrate) {
          const nodes = children(options.target);
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          $$.fragment && $$.fragment.l(nodes);
          nodes.forEach(detach);
        }
        else {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          $$.fragment && $$.fragment.c();
        }
        if (options.intro)
          transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor);
        flush();
      }
      set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
      $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
      }
      $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
          const index = callbacks.indexOf(callback);
          if (index !== -1)
            callbacks.splice(index, 1);
        };
      }
      $set($$props) {
        if (this.$$set && !is_empty($$props)) {
          this.$$.skip_bound = true;
          this.$$set($$props);
          this.$$.skip_bound = false;
        }
      }
    }

    /* node_modules/svelte-integration-red/components/Row.svelte generated by Svelte v3.35.0 */

    function create_fragment$a(ctx) {
      let div;
      let current;
      const default_slot_template = /*#slots*/ ctx[2].default;
      const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

      return {
        c() {
          div = element("div");
          if (default_slot) default_slot.c();
          attr(div, "class", "form-row");
          attr(div, "style", /*style*/ ctx[0]);
        },
        m(target, anchor) {
          insert(target, div, anchor);

          if (default_slot) {
            default_slot.m(div, null);
          }

          current = true;
        },
        p(ctx, [dirty]) {
          if (default_slot) {
            if (default_slot.p && dirty & /*$$scope*/ 2) {
              update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
            }
          }

          if (!current || dirty & /*style*/ 1) {
            attr(div, "style", /*style*/ ctx[0]);
          }
        },
        i(local) {
          if (current) return;
          transition_in(default_slot, local);
          current = true;
        },
        o(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d(detaching) {
          if (detaching) detach(div);
          if (default_slot) default_slot.d(detaching);
        }
      };
    }

    function instance$a($$self, $$props, $$invalidate) {
      let { $$slots: slots = {}, $$scope } = $$props;
      let { style } = $$props;

      $$self.$$set = $$props => {
        if ("style" in $$props) $$invalidate(0, style = $$props.style);
        if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
      };

      return [style, $$scope, slots];
    }

    class Row extends SvelteComponent {
      constructor(options) {
        super();
        init(this, options, instance$a, create_fragment$a, safe_not_equal, { style: 0 });
      }
    }

    function getBooleanFrom (property) {
      return typeof property === 'boolean' ? property : property.toString().toLowerCase() === 'true'
    }

    function getId (prop=null) {
      if (prop) {
        id = prop;
      } else {
        id = Date.now() + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
      }
      return id
    }

    /* node_modules/svelte-integration-red/components/PlainInput.svelte generated by Svelte v3.35.0 */

    function create_else_block_1$2(ctx) {
      let span;

      return {
        c() {
          span = element("span");
          span.textContent = "Error: No property name given.";
          set_style(span, "width", "100%");
        },
        m(target, anchor) {
          insert(target, span, anchor);
        },
        p: noop,
        d(detaching) {
          if (detaching) detach(span);
        }
      };
    }

// (48:0) {#if !updateNode || prop}
    function create_if_block$9(ctx) {
      let t;
      let if_block1_anchor;
      let if_block0 = /*type*/ ctx[2] !== "checkbox" && /*label*/ ctx[3] && create_if_block_8(ctx);

      function select_block_type_1(ctx, dirty) {
        if (/*type*/ ctx[2] === "text") return create_if_block_1$7;
        if (/*type*/ ctx[2] === "number") return create_if_block_2$5;
        if (/*type*/ ctx[2] === "checkbox") return create_if_block_3$4;
        if (/*type*/ ctx[2] === "password") return create_if_block_5$2;
        if (/*type*/ ctx[2] === "email") return create_if_block_6;
        if (/*type*/ ctx[2] === "url") return create_if_block_7;
        return create_else_block$6;
      }

      let current_block_type = select_block_type_1(ctx);
      let if_block1 = current_block_type(ctx);

      return {
        c() {
          if (if_block0) if_block0.c();
          t = space();
          if_block1.c();
          if_block1_anchor = empty();
        },
        m(target, anchor) {
          if (if_block0) if_block0.m(target, anchor);
          insert(target, t, anchor);
          if_block1.m(target, anchor);
          insert(target, if_block1_anchor, anchor);
        },
        p(ctx, dirty) {
          if (/*type*/ ctx[2] !== "checkbox" && /*label*/ ctx[3]) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_8(ctx);
              if_block0.c();
              if_block0.m(t.parentNode, t);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block1) {
            if_block1.p(ctx, dirty);
          } else {
            if_block1.d(1);
            if_block1 = current_block_type(ctx);

            if (if_block1) {
              if_block1.c();
              if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
            }
          }
        },
        d(detaching) {
          if (if_block0) if_block0.d(detaching);
          if (detaching) detach(t);
          if_block1.d(detaching);
          if (detaching) detach(if_block1_anchor);
        }
      };
    }

// (49:4) {#if type !== 'checkbox' && label}
    function create_if_block_8(ctx) {
      let label_1;
      let t0;
      let t1;
      let label_1_for_value;
      let mounted;
      let dispose;
      let if_block = /*icon*/ ctx[6] && create_if_block_9(ctx);

      return {
        c() {
          label_1 = element("label");
          if (if_block) if_block.c();
          t0 = space();
          t1 = text(/*label*/ ctx[3]);
          attr(label_1, "for", label_1_for_value = "node-input-" + /*id*/ ctx[1]);
        },
        m(target, anchor) {
          insert(target, label_1, anchor);
          if (if_block) if_block.m(label_1, null);
          append(label_1, t0);
          append(label_1, t1);

          if (!mounted) {
            dispose = [
              listen(label_1, "mouseenter", /*mouseenter_handler*/ ctx[27]),
              listen(label_1, "mouseleave", /*mouseleave_handler*/ ctx[28])
            ];

            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (/*icon*/ ctx[6]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block_9(ctx);
              if_block.c();
              if_block.m(label_1, t0);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }

          if (dirty[0] & /*label*/ 8) set_data(t1, /*label*/ ctx[3]);

          if (dirty[0] & /*id*/ 2 && label_1_for_value !== (label_1_for_value = "node-input-" + /*id*/ ctx[1])) {
            attr(label_1, "for", label_1_for_value);
          }
        },
        d(detaching) {
          if (detaching) detach(label_1);
          if (if_block) if_block.d();
          mounted = false;
          run_all(dispose);
        }
      };
    }

// (50:65) {#if icon}
    function create_if_block_9(ctx) {
      let i;
      let i_class_value;

      return {
        c() {
          i = element("i");
          attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[6]);
        },
        m(target, anchor) {
          insert(target, i, anchor);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*icon*/ 64 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[6])) {
            attr(i, "class", i_class_value);
          }
        },
        d(detaching) {
          if (detaching) detach(i);
        }
      };
    }

// (67:4) {:else}
    function create_else_block$6(ctx) {
      let span;
      let t0;
      let t1;
      let t2;

      return {
        c() {
          span = element("span");
          t0 = text("Error: Unsupported property type '");
          t1 = text(/*type*/ ctx[2]);
          t2 = text("'.");
        },
        m(target, anchor) {
          insert(target, span, anchor);
          append(span, t0);
          append(span, t1);
          append(span, t2);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*type*/ 4) set_data(t1, /*type*/ ctx[2]);
        },
        d(detaching) {
          if (detaching) detach(span);
        }
      };
    }

// (65:29)
    function create_if_block_7(ctx) {
      let input;
      let input_id_value;
      let input_style_value;
      let mounted;
      let dispose;

      return {
        c() {
          input = element("input");
          attr(input, "type", "url");
          attr(input, "id", input_id_value = "node-input-" + /*id*/ ctx[1]);
          attr(input, "placeholder", /*placeholder*/ ctx[4]);
          input.disabled = /*disabled*/ ctx[8];
          attr(input, "style", input_style_value = /*maximize*/ ctx[7] ? "width: 100%;" : "");
        },
        m(target, anchor) {
          insert(target, input, anchor);
          set_input_value(input, /*value*/ ctx[0]);

          if (!mounted) {
            dispose = [
              listen(input, "mouseenter", /*mouseenter_handler_7*/ ctx[25]),
              listen(input, "mouseleave", /*mouseleave_handler_7*/ ctx[26]),
              listen(input, "input", /*input_input_handler_4*/ ctx[34])
            ];

            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (dirty[0] & /*id*/ 2 && input_id_value !== (input_id_value = "node-input-" + /*id*/ ctx[1])) {
            attr(input, "id", input_id_value);
          }

          if (dirty[0] & /*placeholder*/ 16) {
            attr(input, "placeholder", /*placeholder*/ ctx[4]);
          }

          if (dirty[0] & /*disabled*/ 256) {
            input.disabled = /*disabled*/ ctx[8];
          }

          if (dirty[0] & /*maximize*/ 128 && input_style_value !== (input_style_value = /*maximize*/ ctx[7] ? "width: 100%;" : "")) {
            attr(input, "style", input_style_value);
          }

          if (dirty[0] & /*value*/ 1) {
            set_input_value(input, /*value*/ ctx[0]);
          }
        },
        d(detaching) {
          if (detaching) detach(input);
          mounted = false;
          run_all(dispose);
        }
      };
    }

// (63:31)
    function create_if_block_6(ctx) {
      let input;
      let input_id_value;
      let input_style_value;
      let mounted;
      let dispose;

      return {
        c() {
          input = element("input");
          attr(input, "type", "email");
          attr(input, "id", input_id_value = "node-input-" + /*id*/ ctx[1]);
          attr(input, "placeholder", /*placeholder*/ ctx[4]);
          input.disabled = /*disabled*/ ctx[8];
          attr(input, "style", input_style_value = /*maximize*/ ctx[7] ? "width: 100%;" : "");
        },
        m(target, anchor) {
          insert(target, input, anchor);
          set_input_value(input, /*value*/ ctx[0]);

          if (!mounted) {
            dispose = [
              listen(input, "mouseenter", /*mouseenter_handler_6*/ ctx[23]),
              listen(input, "mouseleave", /*mouseleave_handler_6*/ ctx[24]),
              listen(input, "input", /*input_input_handler_3*/ ctx[33])
            ];

            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (dirty[0] & /*id*/ 2 && input_id_value !== (input_id_value = "node-input-" + /*id*/ ctx[1])) {
            attr(input, "id", input_id_value);
          }

          if (dirty[0] & /*placeholder*/ 16) {
            attr(input, "placeholder", /*placeholder*/ ctx[4]);
          }

          if (dirty[0] & /*disabled*/ 256) {
            input.disabled = /*disabled*/ ctx[8];
          }

          if (dirty[0] & /*maximize*/ 128 && input_style_value !== (input_style_value = /*maximize*/ ctx[7] ? "width: 100%;" : "")) {
            attr(input, "style", input_style_value);
          }

          if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
            set_input_value(input, /*value*/ ctx[0]);
          }
        },
        d(detaching) {
          if (detaching) detach(input);
          mounted = false;
          run_all(dispose);
        }
      };
    }

// (61:34)
    function create_if_block_5$2(ctx) {
      let input;
      let input_id_value;
      let input_style_value;
      let mounted;
      let dispose;

      return {
        c() {
          input = element("input");
          attr(input, "type", "password");
          attr(input, "id", input_id_value = "node-input-" + /*id*/ ctx[1]);
          attr(input, "placeholder", /*placeholder*/ ctx[4]);
          input.disabled = /*disabled*/ ctx[8];
          attr(input, "style", input_style_value = /*maximize*/ ctx[7] ? "width: 100%;" : "");
        },
        m(target, anchor) {
          insert(target, input, anchor);
          set_input_value(input, /*value*/ ctx[0]);

          if (!mounted) {
            dispose = [
              listen(input, "mouseenter", /*mouseenter_handler_5*/ ctx[21]),
              listen(input, "mouseleave", /*mouseleave_handler_5*/ ctx[22]),
              listen(input, "input", /*input_input_handler_2*/ ctx[32])
            ];

            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (dirty[0] & /*id*/ 2 && input_id_value !== (input_id_value = "node-input-" + /*id*/ ctx[1])) {
            attr(input, "id", input_id_value);
          }

          if (dirty[0] & /*placeholder*/ 16) {
            attr(input, "placeholder", /*placeholder*/ ctx[4]);
          }

          if (dirty[0] & /*disabled*/ 256) {
            input.disabled = /*disabled*/ ctx[8];
          }

          if (dirty[0] & /*maximize*/ 128 && input_style_value !== (input_style_value = /*maximize*/ ctx[7] ? "width: 100%;" : "")) {
            attr(input, "style", input_style_value);
          }

          if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
            set_input_value(input, /*value*/ ctx[0]);
          }
        },
        d(detaching) {
          if (detaching) detach(input);
          mounted = false;
          run_all(dispose);
        }
      };
    }

// (56:34)
    function create_if_block_3$4(ctx) {
      let div;
      let input;
      let input_id_value;
      let t0;
      let label_1;
      let t1;
      let t2;
      let label_1_for_value;
      let mounted;
      let dispose;
      let if_block = /*icon*/ ctx[6] && create_if_block_4$3(ctx);

      return {
        c() {
          div = element("div");
          input = element("input");
          t0 = space();
          label_1 = element("label");
          if (if_block) if_block.c();
          t1 = space();
          t2 = text(/*label*/ ctx[3]);
          attr(input, "type", "checkbox");
          attr(input, "id", input_id_value = "node-input-" + /*id*/ ctx[1]);
          input.disabled = /*disabled*/ ctx[8];
          set_style(input, "display", "inline-block");
          set_style(input, "width", "auto");
          set_style(input, "vertical-align", "top");
          set_style(input, "margin-right", "6px");
          attr(label_1, "for", label_1_for_value = "node-input-" + /*id*/ ctx[1]);
          set_style(label_1, "width", "auto");
          set_style(div, "margin-top", "21px");
          set_style(div, "margin-bottom", "16px");
        },
        m(target, anchor) {
          insert(target, div, anchor);
          append(div, input);
          input.checked = /*value*/ ctx[0];
          append(div, t0);
          append(div, label_1);
          if (if_block) if_block.m(label_1, null);
          append(label_1, t1);
          append(label_1, t2);

          if (!mounted) {
            dispose = [
              listen(input, "mouseenter", /*mouseenter_handler_3*/ ctx[19]),
              listen(input, "mouseleave", /*mouseleave_handler_3*/ ctx[20]),
              listen(input, "change", /*input_change_handler*/ ctx[31]),
              listen(label_1, "mouseenter", /*mouseenter_handler_4*/ ctx[17]),
              listen(label_1, "mouseleave", /*mouseleave_handler_4*/ ctx[18])
            ];

            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (dirty[0] & /*id*/ 2 && input_id_value !== (input_id_value = "node-input-" + /*id*/ ctx[1])) {
            attr(input, "id", input_id_value);
          }

          if (dirty[0] & /*disabled*/ 256) {
            input.disabled = /*disabled*/ ctx[8];
          }

          if (dirty[0] & /*value*/ 1) {
            input.checked = /*value*/ ctx[0];
          }

          if (/*icon*/ ctx[6]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block_4$3(ctx);
              if_block.c();
              if_block.m(label_1, t1);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }

          if (dirty[0] & /*label*/ 8) set_data(t2, /*label*/ ctx[3]);

          if (dirty[0] & /*id*/ 2 && label_1_for_value !== (label_1_for_value = "node-input-" + /*id*/ ctx[1])) {
            attr(label_1, "for", label_1_for_value);
          }
        },
        d(detaching) {
          if (detaching) detach(div);
          if (if_block) if_block.d();
          mounted = false;
          run_all(dispose);
        }
      };
    }

// (54:32)
    function create_if_block_2$5(ctx) {
      let input;
      let input_id_value;
      let input_style_value;
      let mounted;
      let dispose;

      return {
        c() {
          input = element("input");
          attr(input, "type", "number");
          attr(input, "id", input_id_value = "node-input-" + /*id*/ ctx[1]);
          attr(input, "placeholder", /*placeholder*/ ctx[4]);
          input.disabled = /*disabled*/ ctx[8];
          attr(input, "style", input_style_value = /*maximize*/ ctx[7] ? "width: 100%;" : "");
        },
        m(target, anchor) {
          insert(target, input, anchor);
          set_input_value(input, /*value*/ ctx[0]);

          if (!mounted) {
            dispose = [
              listen(input, "mouseenter", /*mouseenter_handler_2*/ ctx[15]),
              listen(input, "mouseleave", /*mouseleave_handler_2*/ ctx[16]),
              listen(input, "input", /*input_input_handler_1*/ ctx[30])
            ];

            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (dirty[0] & /*id*/ 2 && input_id_value !== (input_id_value = "node-input-" + /*id*/ ctx[1])) {
            attr(input, "id", input_id_value);
          }

          if (dirty[0] & /*placeholder*/ 16) {
            attr(input, "placeholder", /*placeholder*/ ctx[4]);
          }

          if (dirty[0] & /*disabled*/ 256) {
            input.disabled = /*disabled*/ ctx[8];
          }

          if (dirty[0] & /*maximize*/ 128 && input_style_value !== (input_style_value = /*maximize*/ ctx[7] ? "width: 100%;" : "")) {
            attr(input, "style", input_style_value);
          }

          if (dirty[0] & /*value*/ 1 && to_number(input.value) !== /*value*/ ctx[0]) {
            set_input_value(input, /*value*/ ctx[0]);
          }
        },
        d(detaching) {
          if (detaching) detach(input);
          mounted = false;
          run_all(dispose);
        }
      };
    }

// (52:4) {#if type === 'text'}
    function create_if_block_1$7(ctx) {
      let input;
      let input_id_value;
      let input_style_value;
      let mounted;
      let dispose;

      return {
        c() {
          input = element("input");
          attr(input, "type", "text");
          attr(input, "id", input_id_value = "node-input-" + /*id*/ ctx[1]);
          attr(input, "placeholder", /*placeholder*/ ctx[4]);
          input.disabled = /*disabled*/ ctx[8];
          attr(input, "style", input_style_value = /*maximize*/ ctx[7] ? "width: 100%;" : "");
        },
        m(target, anchor) {
          insert(target, input, anchor);
          set_input_value(input, /*value*/ ctx[0]);

          if (!mounted) {
            dispose = [
              listen(input, "mouseenter", /*mouseenter_handler_1*/ ctx[13]),
              listen(input, "mouseleave", /*mouseleave_handler_1*/ ctx[14]),
              listen(input, "input", /*input_input_handler*/ ctx[29])
            ];

            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (dirty[0] & /*id*/ 2 && input_id_value !== (input_id_value = "node-input-" + /*id*/ ctx[1])) {
            attr(input, "id", input_id_value);
          }

          if (dirty[0] & /*placeholder*/ 16) {
            attr(input, "placeholder", /*placeholder*/ ctx[4]);
          }

          if (dirty[0] & /*disabled*/ 256) {
            input.disabled = /*disabled*/ ctx[8];
          }

          if (dirty[0] & /*maximize*/ 128 && input_style_value !== (input_style_value = /*maximize*/ ctx[7] ? "width: 100%;" : "")) {
            attr(input, "style", input_style_value);
          }

          if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
            set_input_value(input, /*value*/ ctx[0]);
          }
        },
        d(detaching) {
          if (detaching) detach(input);
          mounted = false;
          run_all(dispose);
        }
      };
    }

// (59:89) {#if icon}
    function create_if_block_4$3(ctx) {
      let i;
      let i_class_value;

      return {
        c() {
          i = element("i");
          attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[6]);
        },
        m(target, anchor) {
          insert(target, i, anchor);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*icon*/ 64 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[6])) {
            attr(i, "class", i_class_value);
          }
        },
        d(detaching) {
          if (detaching) detach(i);
        }
      };
    }

    function create_fragment$9(ctx) {
      let if_block_anchor;

      function select_block_type(ctx, dirty) {
        if (!/*updateNode*/ ctx[9] || /*prop*/ ctx[5]) return create_if_block$9;
        return create_else_block_1$2;
      }

      let current_block_type = select_block_type(ctx);
      let if_block = current_block_type(ctx);

      return {
        c() {
          if_block.c();
          if_block_anchor = empty();
        },
        m(target, anchor) {
          if_block.m(target, anchor);
          insert(target, if_block_anchor, anchor);
        },
        p(ctx, dirty) {
          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          }
        },
        i: noop,
        o: noop,
        d(detaching) {
          if_block.d(detaching);
          if (detaching) detach(if_block_anchor);
        }
      };
    }

    function instance$9($$self, $$props, $$invalidate) {
      let { node } = $$props,
        { prop } = $$props,
        { value } = $$props,
        { type } = $$props,
        { icon } = $$props,
        { credentials = false } = $$props,
        { label } = $$props,
        { placeholder } = $$props,
        { maximize } = $$props,
        { id } = $$props,
        { disabled = false } = $$props;

      if (!id) {
        id = getId(prop);
      }

      let defaults;

      if (!node) {
        defaults = {};
      } else {
        defaults = credentials ? node._def.credentials : node._def.defaults;
      }

      const dispatch = createEventDispatcher();
      const updateNode = typeof node !== "undefined";
      value = updateNode && node[prop] || value;
      let init = true;
      label = label || defaults[prop] && defaults[prop].label || prop;
      placeholder = placeholder || defaults.placeholder || "";

      if (!type) {
        let testValue = defaults[prop] ? defaults[prop].value : value;

        if (typeof testValue === "number") {
          type = "number";
        } else if (typeof testValue === "boolean") {
          type = "checkbox";
        } else {
          type = "text";
        }
      }

      function mouseenter_handler_1(event) {
        bubble($$self, event);
      }

      function mouseleave_handler_1(event) {
        bubble($$self, event);
      }

      function mouseenter_handler_2(event) {
        bubble($$self, event);
      }

      function mouseleave_handler_2(event) {
        bubble($$self, event);
      }

      function mouseenter_handler_4(event) {
        bubble($$self, event);
      }

      function mouseleave_handler_4(event) {
        bubble($$self, event);
      }

      function mouseenter_handler_3(event) {
        bubble($$self, event);
      }

      function mouseleave_handler_3(event) {
        bubble($$self, event);
      }

      function mouseenter_handler_5(event) {
        bubble($$self, event);
      }

      function mouseleave_handler_5(event) {
        bubble($$self, event);
      }

      function mouseenter_handler_6(event) {
        bubble($$self, event);
      }

      function mouseleave_handler_6(event) {
        bubble($$self, event);
      }

      function mouseenter_handler_7(event) {
        bubble($$self, event);
      }

      function mouseleave_handler_7(event) {
        bubble($$self, event);
      }

      function mouseenter_handler(event) {
        bubble($$self, event);
      }

      function mouseleave_handler(event) {
        bubble($$self, event);
      }

      function input_input_handler() {
        value = this.value;
        $$invalidate(0, value);
      }

      function input_input_handler_1() {
        value = to_number(this.value);
        $$invalidate(0, value);
      }

      function input_change_handler() {
        value = this.checked;
        $$invalidate(0, value);
      }

      function input_input_handler_2() {
        value = this.value;
        $$invalidate(0, value);
      }

      function input_input_handler_3() {
        value = this.value;
        $$invalidate(0, value);
      }

      function input_input_handler_4() {
        value = this.value;
        $$invalidate(0, value);
      }

      $$self.$$set = $$props => {
        if ("node" in $$props) $$invalidate(10, node = $$props.node);
        if ("prop" in $$props) $$invalidate(5, prop = $$props.prop);
        if ("value" in $$props) $$invalidate(0, value = $$props.value);
        if ("type" in $$props) $$invalidate(2, type = $$props.type);
        if ("icon" in $$props) $$invalidate(6, icon = $$props.icon);
        if ("credentials" in $$props) $$invalidate(11, credentials = $$props.credentials);
        if ("label" in $$props) $$invalidate(3, label = $$props.label);
        if ("placeholder" in $$props) $$invalidate(4, placeholder = $$props.placeholder);
        if ("maximize" in $$props) $$invalidate(7, maximize = $$props.maximize);
        if ("id" in $$props) $$invalidate(1, id = $$props.id);
        if ("disabled" in $$props) $$invalidate(8, disabled = $$props.disabled);
      };

      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & /*prop, value, init, id*/ 4131) {
          {
            if (updateNode) {
              $$invalidate(10, node[prop] = value, node);
            }

            if (!init) {
              dispatch("change", { id, value });
            }

            $$invalidate(12, init = false);
          }
        }
      };

      return [
        value,
        id,
        type,
        label,
        placeholder,
        prop,
        icon,
        maximize,
        disabled,
        updateNode,
        node,
        credentials,
        init,
        mouseenter_handler_1,
        mouseleave_handler_1,
        mouseenter_handler_2,
        mouseleave_handler_2,
        mouseenter_handler_4,
        mouseleave_handler_4,
        mouseenter_handler_3,
        mouseleave_handler_3,
        mouseenter_handler_5,
        mouseleave_handler_5,
        mouseenter_handler_6,
        mouseleave_handler_6,
        mouseenter_handler_7,
        mouseleave_handler_7,
        mouseenter_handler,
        mouseleave_handler,
        input_input_handler,
        input_input_handler_1,
        input_change_handler,
        input_input_handler_2,
        input_input_handler_3,
        input_input_handler_4
      ];
    }

    class PlainInput extends SvelteComponent {
      constructor(options) {
        super();

        init(
          this,
          options,
          instance$9,
          create_fragment$9,
          safe_not_equal,
          {
            node: 10,
            prop: 5,
            value: 0,
            type: 2,
            icon: 6,
            credentials: 11,
            label: 3,
            placeholder: 4,
            maximize: 7,
            id: 1,
            disabled: 8
          },
          [-1, -1]
        );
      }
    }

    /* node_modules/svelte-integration-red/components/ConfigNodeInput.svelte generated by Svelte v3.35.0 */

    function add_css$4() {
      var style = element("style");
      style.id = "svelte-1305hgm-style";
      style.textContent = ".disabled.svelte-1305hgm{pointer-events:none }";
      append(document.head, style);
    }

    function get_each_context$3(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[1] = list[i].id;
      child_ctx[0] = list[i].label;
      return child_ctx;
    }

// (89:0) {:else}
    function create_else_block$5(ctx) {
      let span;

      return {
        c() {
          span = element("span");
          span.textContent = "Error: No property name given.";
          set_style(span, "width", "100%");
        },
        m(target, anchor) {
          insert(target, span, anchor);
        },
        p: noop,
        d(detaching) {
          if (detaching) detach(span);
        }
      };
    }

// (77:0) {#if prop}
    function create_if_block$8(ctx) {
      let label_1;
      let t0;
      let t1;
      let label_1_for_value;
      let t2;
      let div1;
      let div0;
      let select;
      let each_blocks = [];
      let each_1_lookup = new Map();
      let select_id_value;
      let select_placeholder_value;
      let t3;
      let a;
      let i;
      let a_id_value;
      let mounted;
      let dispose;
      let if_block = /*icon*/ ctx[3] && create_if_block_1$6(ctx);
      let each_value = /*configNodes*/ ctx[6];
      const get_key = ctx => /*id*/ ctx[1];

      for (let i = 0; i < each_value.length; i += 1) {
        let child_ctx = get_each_context$3(ctx, each_value, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
      }

      return {
        c() {
          label_1 = element("label");
          if (if_block) if_block.c();
          t0 = space();
          t1 = text(/*label*/ ctx[0]);
          t2 = space();
          div1 = element("div");
          div0 = element("div");
          select = element("select");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t3 = space();
          a = element("a");
          i = element("i");
          attr(label_1, "for", label_1_for_value = "node-input-" + /*prop*/ ctx[2]);
          set_style(select, "width", "100%");
          attr(select, "id", select_id_value = "node-input-" + /*prop*/ ctx[2]);
          attr(select, "placeholder", select_placeholder_value = /*defaults*/ ctx[7][/*prop*/ ctx[2]].label);
          select.disabled = /*disabled*/ ctx[4];
          if (/*selectedNode*/ ctx[5] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[13].call(select));
          set_style(div0, "position", "absolute");
          set_style(div0, "left", "0px");
          set_style(div0, "right", "40px");
          attr(i, "class", "fa fa-pencil");
          attr(a, "id", a_id_value = "node-input-lookup-" + /*prop*/ ctx[2]);
          attr(a, "class", "red-ui-button svelte-1305hgm");
          set_style(a, "position", "absolute");
          set_style(a, "right", "0px");
          set_style(a, "top", "0px");
          toggle_class(a, "disabled", /*disabled*/ ctx[4]);
          set_style(div1, "display", "inline-block");
          set_style(div1, "position", "relative");
          set_style(div1, "width", "70%");
          set_style(div1, "height", "20px");
        },
        m(target, anchor) {
          insert(target, label_1, anchor);
          if (if_block) if_block.m(label_1, null);
          append(label_1, t0);
          append(label_1, t1);
          insert(target, t2, anchor);
          insert(target, div1, anchor);
          append(div1, div0);
          append(div0, select);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(select, null);
          }

          select_option(select, /*selectedNode*/ ctx[5]);
          append(div1, t3);
          append(div1, a);
          append(a, i);

          if (!mounted) {
            dispose = [
              listen(select, "change", /*select_change_handler*/ ctx[13]),
              listen(a, "click", /*editConfigNode*/ ctx[8]),
              listen(div1, "mouseenter", /*mouseenter_handler*/ ctx[11]),
              listen(div1, "mouseleave", /*mouseleave_handler*/ ctx[12])
            ];

            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (/*icon*/ ctx[3]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block_1$6(ctx);
              if_block.c();
              if_block.m(label_1, t0);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }

          if (dirty & /*label*/ 1) set_data(t1, /*label*/ ctx[0]);

          if (dirty & /*prop*/ 4 && label_1_for_value !== (label_1_for_value = "node-input-" + /*prop*/ ctx[2])) {
            attr(label_1, "for", label_1_for_value);
          }

          if (dirty & /*configNodes*/ 64) {
            each_value = /*configNodes*/ ctx[6];
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, select, destroy_block, create_each_block$3, null, get_each_context$3);
          }

          if (dirty & /*prop*/ 4 && select_id_value !== (select_id_value = "node-input-" + /*prop*/ ctx[2])) {
            attr(select, "id", select_id_value);
          }

          if (dirty & /*prop*/ 4 && select_placeholder_value !== (select_placeholder_value = /*defaults*/ ctx[7][/*prop*/ ctx[2]].label)) {
            attr(select, "placeholder", select_placeholder_value);
          }

          if (dirty & /*disabled*/ 16) {
            select.disabled = /*disabled*/ ctx[4];
          }

          if (dirty & /*selectedNode, configNodes*/ 96) {
            select_option(select, /*selectedNode*/ ctx[5]);
          }

          if (dirty & /*prop*/ 4 && a_id_value !== (a_id_value = "node-input-lookup-" + /*prop*/ ctx[2])) {
            attr(a, "id", a_id_value);
          }

          if (dirty & /*disabled*/ 16) {
            toggle_class(a, "disabled", /*disabled*/ ctx[4]);
          }
        },
        d(detaching) {
          if (detaching) detach(label_1);
          if (if_block) if_block.d();
          if (detaching) detach(t2);
          if (detaching) detach(div1);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }

          mounted = false;
          run_all(dispose);
        }
      };
    }

// (78:35) {#if icon}
    function create_if_block_1$6(ctx) {
      let i;
      let i_class_value;

      return {
        c() {
          i = element("i");
          attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[3] + " svelte-1305hgm");
        },
        m(target, anchor) {
          insert(target, i, anchor);
        },
        p(ctx, dirty) {
          if (dirty & /*icon*/ 8 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[3] + " svelte-1305hgm")) {
            attr(i, "class", i_class_value);
          }
        },
        d(detaching) {
          if (detaching) detach(i);
        }
      };
    }

// (82:16) {#each configNodes as { id, label }
    function create_each_block$3(key_1, ctx) {
      let option;
      let t_value = /*label*/ ctx[0] + "";
      let t;
      let option_value_value;

      return {
        key: key_1,
        first: null,
        c() {
          option = element("option");
          t = text(t_value);
          option.__value = option_value_value = /*id*/ ctx[1];
          option.value = option.__value;
          this.first = option;
        },
        m(target, anchor) {
          insert(target, option, anchor);
          append(option, t);
        },
        p(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty & /*configNodes*/ 64 && t_value !== (t_value = /*label*/ ctx[0] + "")) set_data(t, t_value);

          if (dirty & /*configNodes*/ 64 && option_value_value !== (option_value_value = /*id*/ ctx[1])) {
            option.__value = option_value_value;
            option.value = option.__value;
          }
        },
        d(detaching) {
          if (detaching) detach(option);
        }
      };
    }

    function create_fragment$8(ctx) {
      let if_block_anchor;

      function select_block_type(ctx, dirty) {
        if (/*prop*/ ctx[2]) return create_if_block$8;
        return create_else_block$5;
      }

      let current_block_type = select_block_type(ctx);
      let if_block = current_block_type(ctx);

      return {
        c() {
          if_block.c();
          if_block_anchor = empty();
        },
        m(target, anchor) {
          if_block.m(target, anchor);
          insert(target, if_block_anchor, anchor);
        },
        p(ctx, [dirty]) {
          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          }
        },
        i: noop,
        o: noop,
        d(detaching) {
          if_block.d(detaching);
          if (detaching) detach(if_block_anchor);
        }
      };
    }

    function instance$8($$self, $$props, $$invalidate) {
      let { node } = $$props,
        { prop } = $$props,
        { icon } = $$props,
        { label } = $$props,
        { id } = $$props,
        { disabled = false } = $$props;

      if (!id) {
        id = getId(prop);
      }

      const dispatch = createEventDispatcher();
      let defaults = node._def.defaults;
      label = label || defaults[prop] && defaults[prop].label || prop;
      let configNodes = [];
      let previouslySelectedNode = node[prop] || "_ADD_";
      let selectedNode = node[prop] || "_ADD_";

      function updateConfigNodes() {
        $$invalidate(6, configNodes = []);
        const type = defaults[prop].type;
        const node_def = RED.nodes.getType(type);

        RED.nodes.eachConfig(function (config) {
          if (config.type === type) {
            let label = "";

            if (typeof node_def.label === "function") {
              label = node_def.label.call(config);
            } else {
              label = node_def.label;
            }

            configNodes.push({ id: config.id, label });
          }
        });

        $$invalidate(6, configNodes = [...configNodes, { id: "_ADD_", label: `Add new ${type}...` }]);
      }

      onMount(() => {
        updateConfigNodes();

        RED.events.on("nodes:add", e => {
          if (e.type === defaults[prop].type) {
            updateConfigNodes();
            $$invalidate(5, selectedNode = e.id);
          }
        });

        RED.events.on("nodes:change", e => {
          if (e.type === defaults[prop].type) {
            updateConfigNodes();
          }
        });
      });

      function editConfigNode() {
        // The prefix is omitted so the select gets updated by us and not by Node-RED
        RED.editor.editConfig(prop, defaults[prop].type, selectedNode); /*, 'node-input' */
      }

      function mouseenter_handler(event) {
        bubble($$self, event);
      }

      function mouseleave_handler(event) {
        bubble($$self, event);
      }

      function select_change_handler() {
        selectedNode = select_value(this);
        $$invalidate(5, selectedNode);
        $$invalidate(6, configNodes);
      }

      $$self.$$set = $$props => {
        if ("node" in $$props) $$invalidate(9, node = $$props.node);
        if ("prop" in $$props) $$invalidate(2, prop = $$props.prop);
        if ("icon" in $$props) $$invalidate(3, icon = $$props.icon);
        if ("label" in $$props) $$invalidate(0, label = $$props.label);
        if ("id" in $$props) $$invalidate(1, id = $$props.id);
        if ("disabled" in $$props) $$invalidate(4, disabled = $$props.disabled);
      };

      $$self.$$.update = () => {
        if ($$self.$$.dirty & /*selectedNode, previouslySelectedNode, prop*/ 1060) {
          {
            if (selectedNode !== previouslySelectedNode) {
              $$invalidate(9, node[prop] = selectedNode, node);

              dispatch("change", {
                before: previouslySelectedNode,
                after: selectedNode
              });

              $$invalidate(10, previouslySelectedNode = selectedNode);
            }
          }
        }
      };

      return [
        label,
        id,
        prop,
        icon,
        disabled,
        selectedNode,
        configNodes,
        defaults,
        editConfigNode,
        node,
        previouslySelectedNode,
        mouseenter_handler,
        mouseleave_handler,
        select_change_handler
      ];
    }

    class ConfigNodeInput extends SvelteComponent {
      constructor(options) {
        super();
        if (!document.getElementById("svelte-1305hgm-style")) add_css$4();

        init(this, options, instance$8, create_fragment$8, safe_not_equal, {
          node: 9,
          prop: 2,
          icon: 3,
          label: 0,
          id: 1,
          disabled: 4
        });
      }
    }

    /* node_modules/svelte-integration-red/components/Input.svelte generated by Svelte v3.35.0 */

    function create_else_block_1$1(ctx) {
      let row;
      let current;

      row = new Row({
        props: {
          style: /*maximize*/ ctx[8]
            ? "display: flex; align-items: baseline;"
            : "",
          $$slots: { default: [create_default_slot$5] },
          $$scope: { ctx }
        }
      });

      return {
        c() {
          create_component(row.$$.fragment);
        },
        m(target, anchor) {
          mount_component(row, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          const row_changes = {};

          if (dirty[0] & /*maximize*/ 256) row_changes.style = /*maximize*/ ctx[8]
            ? "display: flex; align-items: baseline;"
            : "";

          if (dirty[0] & /*icon, node, prop, label, disabled, type, credentials, id, value, placeholder, maximize*/ 3967 | dirty[1] & /*$$scope*/ 1048576) {
            row_changes.$$scope = { dirty, ctx };
          }

          row.$set(row_changes);
        },
        i(local) {
          if (current) return;
          transition_in(row.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(row.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(row, detaching);
        }
      };
    }

// (20:0) {#if inline}
    function create_if_block$7(ctx) {
      let current_block_type_index;
      let if_block;
      let if_block_anchor;
      let current;
      const if_block_creators = [create_if_block_1$5, create_else_block$4];
      const if_blocks = [];

      function select_block_type_1(ctx, dirty) {
        if (/*type*/ ctx[1] === "config") return 0;
        return 1;
      }

      current_block_type_index = select_block_type_1(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

      return {
        c() {
          if_block.c();
          if_block_anchor = empty();
        },
        m(target, anchor) {
          if_blocks[current_block_type_index].m(target, anchor);
          insert(target, if_block_anchor, anchor);
          current = true;
        },
        p(ctx, dirty) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type_1(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();

            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });

            check_outros();
            if_block = if_blocks[current_block_type_index];

            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            } else {
              if_block.p(ctx, dirty);
            }

            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        },
        i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o(local) {
          transition_out(if_block);
          current = false;
        },
        d(detaching) {
          if_blocks[current_block_type_index].d(detaching);
          if (detaching) detach(if_block_anchor);
        }
      };
    }

// (30:8) {:else}
    function create_else_block_2$1(ctx) {
      let plaininput;
      let updating_node;
      let updating_prop;
      let updating_value;
      let updating_type;
      let updating_icon;
      let updating_label;
      let updating_placeholder;
      let updating_maximize;
      let updating_disabled;
      let current;

      function plaininput_node_binding_1(value) {
        /*plaininput_node_binding_1*/ ctx[39](value);
      }

      function plaininput_prop_binding_1(value) {
        /*plaininput_prop_binding_1*/ ctx[40](value);
      }

      function plaininput_value_binding_1(value) {
        /*plaininput_value_binding_1*/ ctx[41](value);
      }

      function plaininput_type_binding_1(value) {
        /*plaininput_type_binding_1*/ ctx[42](value);
      }

      function plaininput_icon_binding_1(value) {
        /*plaininput_icon_binding_1*/ ctx[43](value);
      }

      function plaininput_label_binding_1(value) {
        /*plaininput_label_binding_1*/ ctx[44](value);
      }

      function plaininput_placeholder_binding_1(value) {
        /*plaininput_placeholder_binding_1*/ ctx[45](value);
      }

      function plaininput_maximize_binding_1(value) {
        /*plaininput_maximize_binding_1*/ ctx[46](value);
      }

      function plaininput_disabled_binding_1(value) {
        /*plaininput_disabled_binding_1*/ ctx[47](value);
      }

      let plaininput_props = {
        credentials: /*credentials*/ ctx[10],
        id: /*id*/ ctx[11]
      };

      if (/*node*/ ctx[2] !== void 0) {
        plaininput_props.node = /*node*/ ctx[2];
      }

      if (/*prop*/ ctx[3] !== void 0) {
        plaininput_props.prop = /*prop*/ ctx[3];
      }

      if (/*value*/ ctx[0] !== void 0) {
        plaininput_props.value = /*value*/ ctx[0];
      }

      if (/*type*/ ctx[1] !== void 0) {
        plaininput_props.type = /*type*/ ctx[1];
      }

      if (/*icon*/ ctx[4] !== void 0) {
        plaininput_props.icon = /*icon*/ ctx[4];
      }

      if (/*label*/ ctx[5] !== void 0) {
        plaininput_props.label = /*label*/ ctx[5];
      }

      if (/*placeholder*/ ctx[6] !== void 0) {
        plaininput_props.placeholder = /*placeholder*/ ctx[6];
      }

      if (/*maximize*/ ctx[8] !== void 0) {
        plaininput_props.maximize = /*maximize*/ ctx[8];
      }

      if (/*disabled*/ ctx[9] !== void 0) {
        plaininput_props.disabled = /*disabled*/ ctx[9];
      }

      plaininput = new PlainInput({ props: plaininput_props });
      binding_callbacks.push(() => bind(plaininput, "node", plaininput_node_binding_1));
      binding_callbacks.push(() => bind(plaininput, "prop", plaininput_prop_binding_1));
      binding_callbacks.push(() => bind(plaininput, "value", plaininput_value_binding_1));
      binding_callbacks.push(() => bind(plaininput, "type", plaininput_type_binding_1));
      binding_callbacks.push(() => bind(plaininput, "icon", plaininput_icon_binding_1));
      binding_callbacks.push(() => bind(plaininput, "label", plaininput_label_binding_1));
      binding_callbacks.push(() => bind(plaininput, "placeholder", plaininput_placeholder_binding_1));
      binding_callbacks.push(() => bind(plaininput, "maximize", plaininput_maximize_binding_1));
      binding_callbacks.push(() => bind(plaininput, "disabled", plaininput_disabled_binding_1));
      plaininput.$on("change", /*change_handler_3*/ ctx[48]);
      plaininput.$on("mouseenter", /*mouseenter_handler_3*/ ctx[49]);
      plaininput.$on("mouseleave", /*mouseleave_handler_3*/ ctx[50]);

      return {
        c() {
          create_component(plaininput.$$.fragment);
        },
        m(target, anchor) {
          mount_component(plaininput, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          const plaininput_changes = {};
          if (dirty[0] & /*credentials*/ 1024) plaininput_changes.credentials = /*credentials*/ ctx[10];
          if (dirty[0] & /*id*/ 2048) plaininput_changes.id = /*id*/ ctx[11];

          if (!updating_node && dirty[0] & /*node*/ 4) {
            updating_node = true;
            plaininput_changes.node = /*node*/ ctx[2];
            add_flush_callback(() => updating_node = false);
          }

          if (!updating_prop && dirty[0] & /*prop*/ 8) {
            updating_prop = true;
            plaininput_changes.prop = /*prop*/ ctx[3];
            add_flush_callback(() => updating_prop = false);
          }

          if (!updating_value && dirty[0] & /*value*/ 1) {
            updating_value = true;
            plaininput_changes.value = /*value*/ ctx[0];
            add_flush_callback(() => updating_value = false);
          }

          if (!updating_type && dirty[0] & /*type*/ 2) {
            updating_type = true;
            plaininput_changes.type = /*type*/ ctx[1];
            add_flush_callback(() => updating_type = false);
          }

          if (!updating_icon && dirty[0] & /*icon*/ 16) {
            updating_icon = true;
            plaininput_changes.icon = /*icon*/ ctx[4];
            add_flush_callback(() => updating_icon = false);
          }

          if (!updating_label && dirty[0] & /*label*/ 32) {
            updating_label = true;
            plaininput_changes.label = /*label*/ ctx[5];
            add_flush_callback(() => updating_label = false);
          }

          if (!updating_placeholder && dirty[0] & /*placeholder*/ 64) {
            updating_placeholder = true;
            plaininput_changes.placeholder = /*placeholder*/ ctx[6];
            add_flush_callback(() => updating_placeholder = false);
          }

          if (!updating_maximize && dirty[0] & /*maximize*/ 256) {
            updating_maximize = true;
            plaininput_changes.maximize = /*maximize*/ ctx[8];
            add_flush_callback(() => updating_maximize = false);
          }

          if (!updating_disabled && dirty[0] & /*disabled*/ 512) {
            updating_disabled = true;
            plaininput_changes.disabled = /*disabled*/ ctx[9];
            add_flush_callback(() => updating_disabled = false);
          }

          plaininput.$set(plaininput_changes);
        },
        i(local) {
          if (current) return;
          transition_in(plaininput.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(plaininput.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(plaininput, detaching);
        }
      };
    }

// (28:8) {#if type === 'config'}
    function create_if_block_2$4(ctx) {
      let confignodeinput;
      let updating_node;
      let updating_prop;
      let updating_label;
      let updating_disabled;
      let current;

      function confignodeinput_node_binding_1(value) {
        /*confignodeinput_node_binding_1*/ ctx[32](value);
      }

      function confignodeinput_prop_binding_1(value) {
        /*confignodeinput_prop_binding_1*/ ctx[33](value);
      }

      function confignodeinput_label_binding_1(value) {
        /*confignodeinput_label_binding_1*/ ctx[34](value);
      }

      function confignodeinput_disabled_binding_1(value) {
        /*confignodeinput_disabled_binding_1*/ ctx[35](value);
      }

      let confignodeinput_props = { icon: /*icon*/ ctx[4] };

      if (/*node*/ ctx[2] !== void 0) {
        confignodeinput_props.node = /*node*/ ctx[2];
      }

      if (/*prop*/ ctx[3] !== void 0) {
        confignodeinput_props.prop = /*prop*/ ctx[3];
      }

      if (/*label*/ ctx[5] !== void 0) {
        confignodeinput_props.label = /*label*/ ctx[5];
      }

      if (/*disabled*/ ctx[9] !== void 0) {
        confignodeinput_props.disabled = /*disabled*/ ctx[9];
      }

      confignodeinput = new ConfigNodeInput({ props: confignodeinput_props });
      binding_callbacks.push(() => bind(confignodeinput, "node", confignodeinput_node_binding_1));
      binding_callbacks.push(() => bind(confignodeinput, "prop", confignodeinput_prop_binding_1));
      binding_callbacks.push(() => bind(confignodeinput, "label", confignodeinput_label_binding_1));
      binding_callbacks.push(() => bind(confignodeinput, "disabled", confignodeinput_disabled_binding_1));
      confignodeinput.$on("change", /*change_handler_2*/ ctx[36]);
      confignodeinput.$on("mouseenter", /*mouseenter_handler_2*/ ctx[37]);
      confignodeinput.$on("mouseleave", /*mouseleave_handler_2*/ ctx[38]);

      return {
        c() {
          create_component(confignodeinput.$$.fragment);
        },
        m(target, anchor) {
          mount_component(confignodeinput, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          const confignodeinput_changes = {};
          if (dirty[0] & /*icon*/ 16) confignodeinput_changes.icon = /*icon*/ ctx[4];

          if (!updating_node && dirty[0] & /*node*/ 4) {
            updating_node = true;
            confignodeinput_changes.node = /*node*/ ctx[2];
            add_flush_callback(() => updating_node = false);
          }

          if (!updating_prop && dirty[0] & /*prop*/ 8) {
            updating_prop = true;
            confignodeinput_changes.prop = /*prop*/ ctx[3];
            add_flush_callback(() => updating_prop = false);
          }

          if (!updating_label && dirty[0] & /*label*/ 32) {
            updating_label = true;
            confignodeinput_changes.label = /*label*/ ctx[5];
            add_flush_callback(() => updating_label = false);
          }

          if (!updating_disabled && dirty[0] & /*disabled*/ 512) {
            updating_disabled = true;
            confignodeinput_changes.disabled = /*disabled*/ ctx[9];
            add_flush_callback(() => updating_disabled = false);
          }

          confignodeinput.$set(confignodeinput_changes);
        },
        i(local) {
          if (current) return;
          transition_in(confignodeinput.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(confignodeinput.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(confignodeinput, detaching);
        }
      };
    }

// (27:4) <Row style="{maximize? 'display: flex; align-items: baseline;' : ''}">
    function create_default_slot$5(ctx) {
      let current_block_type_index;
      let if_block;
      let if_block_anchor;
      let current;
      const if_block_creators = [create_if_block_2$4, create_else_block_2$1];
      const if_blocks = [];

      function select_block_type_2(ctx, dirty) {
        if (/*type*/ ctx[1] === "config") return 0;
        return 1;
      }

      current_block_type_index = select_block_type_2(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

      return {
        c() {
          if_block.c();
          if_block_anchor = empty();
        },
        m(target, anchor) {
          if_blocks[current_block_type_index].m(target, anchor);
          insert(target, if_block_anchor, anchor);
          current = true;
        },
        p(ctx, dirty) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type_2(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();

            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });

            check_outros();
            if_block = if_blocks[current_block_type_index];

            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            } else {
              if_block.p(ctx, dirty);
            }

            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        },
        i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o(local) {
          transition_out(if_block);
          current = false;
        },
        d(detaching) {
          if_blocks[current_block_type_index].d(detaching);
          if (detaching) detach(if_block_anchor);
        }
      };
    }

// (23:4) {:else}
    function create_else_block$4(ctx) {
      let plaininput;
      let updating_node;
      let updating_prop;
      let updating_value;
      let updating_type;
      let updating_icon;
      let updating_label;
      let updating_placeholder;
      let updating_maximize;
      let updating_disabled;
      let current;

      function plaininput_node_binding(value) {
        /*plaininput_node_binding*/ ctx[20](value);
      }

      function plaininput_prop_binding(value) {
        /*plaininput_prop_binding*/ ctx[21](value);
      }

      function plaininput_value_binding(value) {
        /*plaininput_value_binding*/ ctx[22](value);
      }

      function plaininput_type_binding(value) {
        /*plaininput_type_binding*/ ctx[23](value);
      }

      function plaininput_icon_binding(value) {
        /*plaininput_icon_binding*/ ctx[24](value);
      }

      function plaininput_label_binding(value) {
        /*plaininput_label_binding*/ ctx[25](value);
      }

      function plaininput_placeholder_binding(value) {
        /*plaininput_placeholder_binding*/ ctx[26](value);
      }

      function plaininput_maximize_binding(value) {
        /*plaininput_maximize_binding*/ ctx[27](value);
      }

      function plaininput_disabled_binding(value) {
        /*plaininput_disabled_binding*/ ctx[28](value);
      }

      let plaininput_props = {
        credentials: /*credentials*/ ctx[10],
        id: /*id*/ ctx[11]
      };

      if (/*node*/ ctx[2] !== void 0) {
        plaininput_props.node = /*node*/ ctx[2];
      }

      if (/*prop*/ ctx[3] !== void 0) {
        plaininput_props.prop = /*prop*/ ctx[3];
      }

      if (/*value*/ ctx[0] !== void 0) {
        plaininput_props.value = /*value*/ ctx[0];
      }

      if (/*type*/ ctx[1] !== void 0) {
        plaininput_props.type = /*type*/ ctx[1];
      }

      if (/*icon*/ ctx[4] !== void 0) {
        plaininput_props.icon = /*icon*/ ctx[4];
      }

      if (/*label*/ ctx[5] !== void 0) {
        plaininput_props.label = /*label*/ ctx[5];
      }

      if (/*placeholder*/ ctx[6] !== void 0) {
        plaininput_props.placeholder = /*placeholder*/ ctx[6];
      }

      if (/*maximize*/ ctx[8] !== void 0) {
        plaininput_props.maximize = /*maximize*/ ctx[8];
      }

      if (/*disabled*/ ctx[9] !== void 0) {
        plaininput_props.disabled = /*disabled*/ ctx[9];
      }

      plaininput = new PlainInput({ props: plaininput_props });
      binding_callbacks.push(() => bind(plaininput, "node", plaininput_node_binding));
      binding_callbacks.push(() => bind(plaininput, "prop", plaininput_prop_binding));
      binding_callbacks.push(() => bind(plaininput, "value", plaininput_value_binding));
      binding_callbacks.push(() => bind(plaininput, "type", plaininput_type_binding));
      binding_callbacks.push(() => bind(plaininput, "icon", plaininput_icon_binding));
      binding_callbacks.push(() => bind(plaininput, "label", plaininput_label_binding));
      binding_callbacks.push(() => bind(plaininput, "placeholder", plaininput_placeholder_binding));
      binding_callbacks.push(() => bind(plaininput, "maximize", plaininput_maximize_binding));
      binding_callbacks.push(() => bind(plaininput, "disabled", plaininput_disabled_binding));
      plaininput.$on("change", /*change_handler_1*/ ctx[29]);
      plaininput.$on("mouseenter", /*mouseenter_handler_1*/ ctx[30]);
      plaininput.$on("mouseleave", /*mouseleave_handler_1*/ ctx[31]);

      return {
        c() {
          create_component(plaininput.$$.fragment);
        },
        m(target, anchor) {
          mount_component(plaininput, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          const plaininput_changes = {};
          if (dirty[0] & /*credentials*/ 1024) plaininput_changes.credentials = /*credentials*/ ctx[10];
          if (dirty[0] & /*id*/ 2048) plaininput_changes.id = /*id*/ ctx[11];

          if (!updating_node && dirty[0] & /*node*/ 4) {
            updating_node = true;
            plaininput_changes.node = /*node*/ ctx[2];
            add_flush_callback(() => updating_node = false);
          }

          if (!updating_prop && dirty[0] & /*prop*/ 8) {
            updating_prop = true;
            plaininput_changes.prop = /*prop*/ ctx[3];
            add_flush_callback(() => updating_prop = false);
          }

          if (!updating_value && dirty[0] & /*value*/ 1) {
            updating_value = true;
            plaininput_changes.value = /*value*/ ctx[0];
            add_flush_callback(() => updating_value = false);
          }

          if (!updating_type && dirty[0] & /*type*/ 2) {
            updating_type = true;
            plaininput_changes.type = /*type*/ ctx[1];
            add_flush_callback(() => updating_type = false);
          }

          if (!updating_icon && dirty[0] & /*icon*/ 16) {
            updating_icon = true;
            plaininput_changes.icon = /*icon*/ ctx[4];
            add_flush_callback(() => updating_icon = false);
          }

          if (!updating_label && dirty[0] & /*label*/ 32) {
            updating_label = true;
            plaininput_changes.label = /*label*/ ctx[5];
            add_flush_callback(() => updating_label = false);
          }

          if (!updating_placeholder && dirty[0] & /*placeholder*/ 64) {
            updating_placeholder = true;
            plaininput_changes.placeholder = /*placeholder*/ ctx[6];
            add_flush_callback(() => updating_placeholder = false);
          }

          if (!updating_maximize && dirty[0] & /*maximize*/ 256) {
            updating_maximize = true;
            plaininput_changes.maximize = /*maximize*/ ctx[8];
            add_flush_callback(() => updating_maximize = false);
          }

          if (!updating_disabled && dirty[0] & /*disabled*/ 512) {
            updating_disabled = true;
            plaininput_changes.disabled = /*disabled*/ ctx[9];
            add_flush_callback(() => updating_disabled = false);
          }

          plaininput.$set(plaininput_changes);
        },
        i(local) {
          if (current) return;
          transition_in(plaininput.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(plaininput.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(plaininput, detaching);
        }
      };
    }

// (21:4) {#if type === 'config'}
    function create_if_block_1$5(ctx) {
      let confignodeinput;
      let updating_node;
      let updating_prop;
      let updating_label;
      let updating_disabled;
      let current;

      function confignodeinput_node_binding(value) {
        /*confignodeinput_node_binding*/ ctx[13](value);
      }

      function confignodeinput_prop_binding(value) {
        /*confignodeinput_prop_binding*/ ctx[14](value);
      }

      function confignodeinput_label_binding(value) {
        /*confignodeinput_label_binding*/ ctx[15](value);
      }

      function confignodeinput_disabled_binding(value) {
        /*confignodeinput_disabled_binding*/ ctx[16](value);
      }

      let confignodeinput_props = { icon: /*icon*/ ctx[4] };

      if (/*node*/ ctx[2] !== void 0) {
        confignodeinput_props.node = /*node*/ ctx[2];
      }

      if (/*prop*/ ctx[3] !== void 0) {
        confignodeinput_props.prop = /*prop*/ ctx[3];
      }

      if (/*label*/ ctx[5] !== void 0) {
        confignodeinput_props.label = /*label*/ ctx[5];
      }

      if (/*disabled*/ ctx[9] !== void 0) {
        confignodeinput_props.disabled = /*disabled*/ ctx[9];
      }

      confignodeinput = new ConfigNodeInput({ props: confignodeinput_props });
      binding_callbacks.push(() => bind(confignodeinput, "node", confignodeinput_node_binding));
      binding_callbacks.push(() => bind(confignodeinput, "prop", confignodeinput_prop_binding));
      binding_callbacks.push(() => bind(confignodeinput, "label", confignodeinput_label_binding));
      binding_callbacks.push(() => bind(confignodeinput, "disabled", confignodeinput_disabled_binding));
      confignodeinput.$on("change", /*change_handler*/ ctx[17]);
      confignodeinput.$on("mouseenter", /*mouseenter_handler*/ ctx[18]);
      confignodeinput.$on("mouseleave", /*mouseleave_handler*/ ctx[19]);

      return {
        c() {
          create_component(confignodeinput.$$.fragment);
        },
        m(target, anchor) {
          mount_component(confignodeinput, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          const confignodeinput_changes = {};
          if (dirty[0] & /*icon*/ 16) confignodeinput_changes.icon = /*icon*/ ctx[4];

          if (!updating_node && dirty[0] & /*node*/ 4) {
            updating_node = true;
            confignodeinput_changes.node = /*node*/ ctx[2];
            add_flush_callback(() => updating_node = false);
          }

          if (!updating_prop && dirty[0] & /*prop*/ 8) {
            updating_prop = true;
            confignodeinput_changes.prop = /*prop*/ ctx[3];
            add_flush_callback(() => updating_prop = false);
          }

          if (!updating_label && dirty[0] & /*label*/ 32) {
            updating_label = true;
            confignodeinput_changes.label = /*label*/ ctx[5];
            add_flush_callback(() => updating_label = false);
          }

          if (!updating_disabled && dirty[0] & /*disabled*/ 512) {
            updating_disabled = true;
            confignodeinput_changes.disabled = /*disabled*/ ctx[9];
            add_flush_callback(() => updating_disabled = false);
          }

          confignodeinput.$set(confignodeinput_changes);
        },
        i(local) {
          if (current) return;
          transition_in(confignodeinput.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(confignodeinput.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(confignodeinput, detaching);
        }
      };
    }

    function create_fragment$7(ctx) {
      let current_block_type_index;
      let if_block;
      let if_block_anchor;
      let current;
      const if_block_creators = [create_if_block$7, create_else_block_1$1];
      const if_blocks = [];

      function select_block_type(ctx, dirty) {
        if (/*inline*/ ctx[7]) return 0;
        return 1;
      }

      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

      return {
        c() {
          if_block.c();
          if_block_anchor = empty();
        },
        m(target, anchor) {
          if_blocks[current_block_type_index].m(target, anchor);
          insert(target, if_block_anchor, anchor);
          current = true;
        },
        p(ctx, dirty) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();

            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });

            check_outros();
            if_block = if_blocks[current_block_type_index];

            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            } else {
              if_block.p(ctx, dirty);
            }

            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        },
        i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o(local) {
          transition_out(if_block);
          current = false;
        },
        d(detaching) {
          if_blocks[current_block_type_index].d(detaching);
          if (detaching) detach(if_block_anchor);
        }
      };
    }

    function instance$7($$self, $$props, $$invalidate) {
      let { node } = $$props,
        { prop } = $$props,
        { value } = $$props,
        { type } = $$props,
        { icon } = $$props,
        { credentials } = $$props,
        { label } = $$props,
        { placeholder } = $$props,
        { id } = $$props,
        { inline = false } = $$props,
        { maximize = false } = $$props,
        { checked } = $$props,
        { disabled = false } = $$props;

      if (type === "checkbox" && typeof checked !== "undefined") {
        value = getBooleanFrom(checked);
      }

      inline = getBooleanFrom(inline);
      maximize = getBooleanFrom(maximize);
      disabled = getBooleanFrom(disabled);

      function confignodeinput_node_binding(value) {
        node = value;
        $$invalidate(2, node);
      }

      function confignodeinput_prop_binding(value) {
        prop = value;
        $$invalidate(3, prop);
      }

      function confignodeinput_label_binding(value) {
        label = value;
        $$invalidate(5, label);
      }

      function confignodeinput_disabled_binding(value) {
        disabled = value;
        $$invalidate(9, disabled);
      }

      function change_handler(event) {
        bubble($$self, event);
      }

      function mouseenter_handler(event) {
        bubble($$self, event);
      }

      function mouseleave_handler(event) {
        bubble($$self, event);
      }

      function plaininput_node_binding(value) {
        node = value;
        $$invalidate(2, node);
      }

      function plaininput_prop_binding(value) {
        prop = value;
        $$invalidate(3, prop);
      }

      function plaininput_value_binding(value$1) {
        value = value$1;
        $$invalidate(0, value);
      }

      function plaininput_type_binding(value) {
        type = value;
        $$invalidate(1, type);
      }

      function plaininput_icon_binding(value) {
        icon = value;
        $$invalidate(4, icon);
      }

      function plaininput_label_binding(value) {
        label = value;
        $$invalidate(5, label);
      }

      function plaininput_placeholder_binding(value) {
        placeholder = value;
        $$invalidate(6, placeholder);
      }

      function plaininput_maximize_binding(value) {
        maximize = value;
        $$invalidate(8, maximize);
      }

      function plaininput_disabled_binding(value) {
        disabled = value;
        $$invalidate(9, disabled);
      }

      function change_handler_1(event) {
        bubble($$self, event);
      }

      function mouseenter_handler_1(event) {
        bubble($$self, event);
      }

      function mouseleave_handler_1(event) {
        bubble($$self, event);
      }

      function confignodeinput_node_binding_1(value) {
        node = value;
        $$invalidate(2, node);
      }

      function confignodeinput_prop_binding_1(value) {
        prop = value;
        $$invalidate(3, prop);
      }

      function confignodeinput_label_binding_1(value) {
        label = value;
        $$invalidate(5, label);
      }

      function confignodeinput_disabled_binding_1(value) {
        disabled = value;
        $$invalidate(9, disabled);
      }

      function change_handler_2(event) {
        bubble($$self, event);
      }

      function mouseenter_handler_2(event) {
        bubble($$self, event);
      }

      function mouseleave_handler_2(event) {
        bubble($$self, event);
      }

      function plaininput_node_binding_1(value) {
        node = value;
        $$invalidate(2, node);
      }

      function plaininput_prop_binding_1(value) {
        prop = value;
        $$invalidate(3, prop);
      }

      function plaininput_value_binding_1(value$1) {
        value = value$1;
        $$invalidate(0, value);
      }

      function plaininput_type_binding_1(value) {
        type = value;
        $$invalidate(1, type);
      }

      function plaininput_icon_binding_1(value) {
        icon = value;
        $$invalidate(4, icon);
      }

      function plaininput_label_binding_1(value) {
        label = value;
        $$invalidate(5, label);
      }

      function plaininput_placeholder_binding_1(value) {
        placeholder = value;
        $$invalidate(6, placeholder);
      }

      function plaininput_maximize_binding_1(value) {
        maximize = value;
        $$invalidate(8, maximize);
      }

      function plaininput_disabled_binding_1(value) {
        disabled = value;
        $$invalidate(9, disabled);
      }

      function change_handler_3(event) {
        bubble($$self, event);
      }

      function mouseenter_handler_3(event) {
        bubble($$self, event);
      }

      function mouseleave_handler_3(event) {
        bubble($$self, event);
      }

      $$self.$$set = $$props => {
        if ("node" in $$props) $$invalidate(2, node = $$props.node);
        if ("prop" in $$props) $$invalidate(3, prop = $$props.prop);
        if ("value" in $$props) $$invalidate(0, value = $$props.value);
        if ("type" in $$props) $$invalidate(1, type = $$props.type);
        if ("icon" in $$props) $$invalidate(4, icon = $$props.icon);
        if ("credentials" in $$props) $$invalidate(10, credentials = $$props.credentials);
        if ("label" in $$props) $$invalidate(5, label = $$props.label);
        if ("placeholder" in $$props) $$invalidate(6, placeholder = $$props.placeholder);
        if ("id" in $$props) $$invalidate(11, id = $$props.id);
        if ("inline" in $$props) $$invalidate(7, inline = $$props.inline);
        if ("maximize" in $$props) $$invalidate(8, maximize = $$props.maximize);
        if ("checked" in $$props) $$invalidate(12, checked = $$props.checked);
        if ("disabled" in $$props) $$invalidate(9, disabled = $$props.disabled);
      };

      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & /*type, checked, value*/ 4099) {
          if (type === "checkbox" && typeof checked !== "undefined") {
            $$invalidate(12, checked = value);
          }
        }
      };

      return [
        value,
        type,
        node,
        prop,
        icon,
        label,
        placeholder,
        inline,
        maximize,
        disabled,
        credentials,
        id,
        checked,
        confignodeinput_node_binding,
        confignodeinput_prop_binding,
        confignodeinput_label_binding,
        confignodeinput_disabled_binding,
        change_handler,
        mouseenter_handler,
        mouseleave_handler,
        plaininput_node_binding,
        plaininput_prop_binding,
        plaininput_value_binding,
        plaininput_type_binding,
        plaininput_icon_binding,
        plaininput_label_binding,
        plaininput_placeholder_binding,
        plaininput_maximize_binding,
        plaininput_disabled_binding,
        change_handler_1,
        mouseenter_handler_1,
        mouseleave_handler_1,
        confignodeinput_node_binding_1,
        confignodeinput_prop_binding_1,
        confignodeinput_label_binding_1,
        confignodeinput_disabled_binding_1,
        change_handler_2,
        mouseenter_handler_2,
        mouseleave_handler_2,
        plaininput_node_binding_1,
        plaininput_prop_binding_1,
        plaininput_value_binding_1,
        plaininput_type_binding_1,
        plaininput_icon_binding_1,
        plaininput_label_binding_1,
        plaininput_placeholder_binding_1,
        plaininput_maximize_binding_1,
        plaininput_disabled_binding_1,
        change_handler_3,
        mouseenter_handler_3,
        mouseleave_handler_3
      ];
    }

    class Input extends SvelteComponent {
      constructor(options) {
        super();

        init(
          this,
          options,
          instance$7,
          create_fragment$7,
          safe_not_equal,
          {
            node: 2,
            prop: 3,
            value: 0,
            type: 1,
            icon: 4,
            credentials: 10,
            label: 5,
            placeholder: 6,
            id: 11,
            inline: 7,
            maximize: 8,
            checked: 12,
            disabled: 9
          },
          [-1, -1]
        );
      }
    }

    /* node_modules/svelte-integration-red/components/PlainTypedInput.svelte generated by Svelte v3.35.0 */

    function create_else_block$3(ctx) {
      let span;

      return {
        c() {
          span = element("span");
          span.textContent = "Error: Neither property nor type property name given.";
          set_style(span, "width", "100%");
        },
        m(target, anchor) {
          insert(target, span, anchor);
        },
        p: noop,
        d(detaching) {
          if (detaching) detach(span);
        }
      };
    }

// (73:19)
    function create_if_block_3$3(ctx) {
      let span;

      return {
        c() {
          span = element("span");
          span.textContent = "Error: No property name given.";
          set_style(span, "width", "100%");
        },
        m(target, anchor) {
          insert(target, span, anchor);
        },
        p: noop,
        d(detaching) {
          if (detaching) detach(span);
        }
      };
    }

// (71:15)
    function create_if_block_2$3(ctx) {
      let span;

      return {
        c() {
          span = element("span");
          span.textContent = "Error: No type property name given.";
          set_style(span, "width", "100%");
        },
        m(target, anchor) {
          insert(target, span, anchor);
        },
        p: noop,
        d(detaching) {
          if (detaching) detach(span);
        }
      };
    }

// (67:0) {#if !updateNode || (prop && typeProp)}
    function create_if_block$6(ctx) {
      let label_1;
      let t0;
      let t1;
      let label_1_for_value;
      let t2;
      let input0;
      let input0_id_value;
      let t3;
      let input1;
      let input1_id_value;
      let mounted;
      let dispose;
      let if_block = /*icon*/ ctx[6] && create_if_block_1$4(ctx);

      return {
        c() {
          label_1 = element("label");
          if (if_block) if_block.c();
          t0 = space();
          t1 = text(/*label*/ ctx[2]);
          t2 = space();
          input0 = element("input");
          t3 = space();
          input1 = element("input");
          attr(label_1, "for", label_1_for_value = "node-input-" + /*id*/ ctx[3]);
          attr(input0, "type", "text");
          attr(input0, "id", input0_id_value = "node-input-" + /*id*/ ctx[3]);
          set_style(input0, "width", /*width*/ ctx[7]);
          attr(input1, "type", "hidden");
          attr(input1, "id", input1_id_value = "node-input-" + /*id*/ ctx[3] + "-type");
        },
        m(target, anchor) {
          insert(target, label_1, anchor);
          if (if_block) if_block.m(label_1, null);
          append(label_1, t0);
          append(label_1, t1);
          insert(target, t2, anchor);
          insert(target, input0, anchor);
          set_input_value(input0, /*value*/ ctx[0]);
          insert(target, t3, anchor);
          insert(target, input1, anchor);
          set_input_value(input1, /*type*/ ctx[1]);

          if (!mounted) {
            dispose = [
              listen(label_1, "mouseenter", /*mouseenter_handler*/ ctx[16]),
              listen(label_1, "mouseleave", /*mouseleave_handler*/ ctx[17]),
              listen(input0, "mouseenter", /*mouseenter_handler_1*/ ctx[14]),
              listen(input0, "mouseleave", /*mouseleave_handler_1*/ ctx[15]),
              listen(input0, "input", /*input0_input_handler*/ ctx[18]),
              listen(input1, "mouseenter", /*mouseenter_handler_2*/ ctx[12]),
              listen(input1, "mouseleave", /*mouseleave_handler_2*/ ctx[13]),
              listen(input1, "input", /*input1_input_handler*/ ctx[19])
            ];

            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (/*icon*/ ctx[6]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block_1$4(ctx);
              if_block.c();
              if_block.m(label_1, t0);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }

          if (dirty & /*label*/ 4) set_data(t1, /*label*/ ctx[2]);

          if (dirty & /*id*/ 8 && label_1_for_value !== (label_1_for_value = "node-input-" + /*id*/ ctx[3])) {
            attr(label_1, "for", label_1_for_value);
          }

          if (dirty & /*id*/ 8 && input0_id_value !== (input0_id_value = "node-input-" + /*id*/ ctx[3])) {
            attr(input0, "id", input0_id_value);
          }

          if (dirty & /*width*/ 128) {
            set_style(input0, "width", /*width*/ ctx[7]);
          }

          if (dirty & /*value*/ 1 && input0.value !== /*value*/ ctx[0]) {
            set_input_value(input0, /*value*/ ctx[0]);
          }

          if (dirty & /*id*/ 8 && input1_id_value !== (input1_id_value = "node-input-" + /*id*/ ctx[3] + "-type")) {
            attr(input1, "id", input1_id_value);
          }

          if (dirty & /*type*/ 2) {
            set_input_value(input1, /*type*/ ctx[1]);
          }
        },
        d(detaching) {
          if (detaching) detach(label_1);
          if (if_block) if_block.d();
          if (detaching) detach(t2);
          if (detaching) detach(input0);
          if (detaching) detach(t3);
          if (detaching) detach(input1);
          mounted = false;
          run_all(dispose);
        }
      };
    }

// (68:61) {#if icon}
    function create_if_block_1$4(ctx) {
      let i;
      let i_class_value;

      return {
        c() {
          i = element("i");
          attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[6]);
        },
        m(target, anchor) {
          insert(target, i, anchor);
        },
        p(ctx, dirty) {
          if (dirty & /*icon*/ 64 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[6])) {
            attr(i, "class", i_class_value);
          }
        },
        d(detaching) {
          if (detaching) detach(i);
        }
      };
    }

    function create_fragment$6(ctx) {
      let if_block_anchor;

      function select_block_type(ctx, dirty) {
        if (!/*updateNode*/ ctx[8] || /*prop*/ ctx[4] && /*typeProp*/ ctx[5]) return create_if_block$6;
        if (/*prop*/ ctx[4]) return create_if_block_2$3;
        if (/*typeProp*/ ctx[5]) return create_if_block_3$3;
        return create_else_block$3;
      }

      let current_block_type = select_block_type(ctx);
      let if_block = current_block_type(ctx);

      return {
        c() {
          if_block.c();
          if_block_anchor = empty();
        },
        m(target, anchor) {
          if_block.m(target, anchor);
          insert(target, if_block_anchor, anchor);
        },
        p(ctx, [dirty]) {
          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          }
        },
        i: noop,
        o: noop,
        d(detaching) {
          if_block.d(detaching);
          if (detaching) detach(if_block_anchor);
        }
      };
    }

    function instance$6($$self, $$props, $$invalidate) {
      let { node } = $$props,
        { prop } = $$props,
        { typeProp } = $$props,
        { value } = $$props,
        { type } = $$props,
        { types } = $$props,
        { icon } = $$props,
        { width } = $$props,
        { label } = $$props,
        { id } = $$props,
        { disabled = false } = $$props;

      if (!id) {
        id = getId(prop);
      }

      let defaults;

      if (!node) {
        defaults = {};
      } else {
        defaults = node._def.defaults;
      }

      const dispatch = createEventDispatcher();
      const updateNode = typeof node !== "undefined";
      value = updateNode && node[prop] || value;
      type = updateNode && node[typeProp] || type;
      label = label || defaults[prop] && defaults[prop].label || prop;

      if (!types && node[typeProp]) {
        types = defaults[typeProp].types;
      }

      let initialized = false;

      onMount(() => {
        window.$("#node-input-" + id).typedInput({
          types,
          typeField: `#node-input-${id}-type`
        });

        window.$("#node-input-" + id).typedInput("disable", disabled); // no effect if stated in the object above

        window.$("#node-input-" + id).on("change", (type, value) => {
          value = window.$("#node-input-" + id).typedInput("value");
          type = window.$("#node-input-" + id).typedInput("type");

          if (updateNode) {
            $$invalidate(10, node[prop] = value, node);
            $$invalidate(10, node[typeProp] = type, node);
          }

          dispatch("change", { id, value, type });
        });

        initialized = true;
      });

      function updateTypes(types) {
        if (initialized) {
          window.$("#node-input-" + id).typedInput("types", types);
        }
      }

      function allowInput(disabled) {
        if (initialized) {
          window.$("#node-input-" + id).typedInput("disable", disabled);
        }
      }

      function mouseenter_handler_2(event) {
        bubble($$self, event);
      }

      function mouseleave_handler_2(event) {
        bubble($$self, event);
      }

      function mouseenter_handler_1(event) {
        bubble($$self, event);
      }

      function mouseleave_handler_1(event) {
        bubble($$self, event);
      }

      function mouseenter_handler(event) {
        bubble($$self, event);
      }

      function mouseleave_handler(event) {
        bubble($$self, event);
      }

      function input0_input_handler() {
        value = this.value;
        $$invalidate(0, value);
      }

      function input1_input_handler() {
        type = this.value;
        $$invalidate(1, type);
      }

      $$self.$$set = $$props => {
        if ("node" in $$props) $$invalidate(10, node = $$props.node);
        if ("prop" in $$props) $$invalidate(4, prop = $$props.prop);
        if ("typeProp" in $$props) $$invalidate(5, typeProp = $$props.typeProp);
        if ("value" in $$props) $$invalidate(0, value = $$props.value);
        if ("type" in $$props) $$invalidate(1, type = $$props.type);
        if ("types" in $$props) $$invalidate(9, types = $$props.types);
        if ("icon" in $$props) $$invalidate(6, icon = $$props.icon);
        if ("width" in $$props) $$invalidate(7, width = $$props.width);
        if ("label" in $$props) $$invalidate(2, label = $$props.label);
        if ("id" in $$props) $$invalidate(3, id = $$props.id);
        if ("disabled" in $$props) $$invalidate(11, disabled = $$props.disabled);
      };

      $$self.$$.update = () => {
        if ($$self.$$.dirty & /*types*/ 512) {
          updateTypes(types);
        }

        if ($$self.$$.dirty & /*disabled*/ 2048) {
          allowInput(disabled);
        }
      };

      return [
        value,
        type,
        label,
        id,
        prop,
        typeProp,
        icon,
        width,
        updateNode,
        types,
        node,
        disabled,
        mouseenter_handler_2,
        mouseleave_handler_2,
        mouseenter_handler_1,
        mouseleave_handler_1,
        mouseenter_handler,
        mouseleave_handler,
        input0_input_handler,
        input1_input_handler
      ];
    }

    class PlainTypedInput extends SvelteComponent {
      constructor(options) {
        super();

        init(this, options, instance$6, create_fragment$6, safe_not_equal, {
          node: 10,
          prop: 4,
          typeProp: 5,
          value: 0,
          type: 1,
          types: 9,
          icon: 6,
          width: 7,
          label: 2,
          id: 3,
          disabled: 11
        });
      }
    }

    /* node_modules/svelte-integration-red/components/TypedInput.svelte generated by Svelte v3.35.0 */

    function create_else_block$2(ctx) {
      let row;
      let current;

      row = new Row({
        props: {
          $$slots: { default: [create_default_slot$4] },
          $$scope: { ctx }
        }
      });

      return {
        c() {
          create_component(row.$$.fragment);
        },
        m(target, anchor) {
          mount_component(row, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          const row_changes = {};

          if (dirty[0] & /*icon, id, node, prop, typeProp, value, type, types, label, disabled*/ 1919 | dirty[1] & /*$$scope*/ 4) {
            row_changes.$$scope = { dirty, ctx };
          }

          row.$set(row_changes);
        },
        i(local) {
          if (current) return;
          transition_in(row.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(row.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(row, detaching);
        }
      };
    }

// (11:0) {#if inline}
    function create_if_block$5(ctx) {
      let plaintypedinput;
      let updating_node;
      let updating_prop;
      let updating_typeProp;
      let updating_value;
      let updating_type;
      let updating_types;
      let updating_label;
      let updating_disabled;
      let current;

      function plaintypedinput_node_binding(value) {
        /*plaintypedinput_node_binding*/ ctx[11](value);
      }

      function plaintypedinput_prop_binding(value) {
        /*plaintypedinput_prop_binding*/ ctx[12](value);
      }

      function plaintypedinput_typeProp_binding(value) {
        /*plaintypedinput_typeProp_binding*/ ctx[13](value);
      }

      function plaintypedinput_value_binding(value) {
        /*plaintypedinput_value_binding*/ ctx[14](value);
      }

      function plaintypedinput_type_binding(value) {
        /*plaintypedinput_type_binding*/ ctx[15](value);
      }

      function plaintypedinput_types_binding(value) {
        /*plaintypedinput_types_binding*/ ctx[16](value);
      }

      function plaintypedinput_label_binding(value) {
        /*plaintypedinput_label_binding*/ ctx[17](value);
      }

      function plaintypedinput_disabled_binding(value) {
        /*plaintypedinput_disabled_binding*/ ctx[18](value);
      }

      let plaintypedinput_props = {
        icon: /*icon*/ ctx[9],
        id: /*id*/ ctx[10],
        width: "70%"
      };

      if (/*node*/ ctx[0] !== void 0) {
        plaintypedinput_props.node = /*node*/ ctx[0];
      }

      if (/*prop*/ ctx[1] !== void 0) {
        plaintypedinput_props.prop = /*prop*/ ctx[1];
      }

      if (/*typeProp*/ ctx[2] !== void 0) {
        plaintypedinput_props.typeProp = /*typeProp*/ ctx[2];
      }

      if (/*value*/ ctx[3] !== void 0) {
        plaintypedinput_props.value = /*value*/ ctx[3];
      }

      if (/*type*/ ctx[4] !== void 0) {
        plaintypedinput_props.type = /*type*/ ctx[4];
      }

      if (/*types*/ ctx[5] !== void 0) {
        plaintypedinput_props.types = /*types*/ ctx[5];
      }

      if (/*label*/ ctx[6] !== void 0) {
        plaintypedinput_props.label = /*label*/ ctx[6];
      }

      if (/*disabled*/ ctx[8] !== void 0) {
        plaintypedinput_props.disabled = /*disabled*/ ctx[8];
      }

      plaintypedinput = new PlainTypedInput({ props: plaintypedinput_props });
      binding_callbacks.push(() => bind(plaintypedinput, "node", plaintypedinput_node_binding));
      binding_callbacks.push(() => bind(plaintypedinput, "prop", plaintypedinput_prop_binding));
      binding_callbacks.push(() => bind(plaintypedinput, "typeProp", plaintypedinput_typeProp_binding));
      binding_callbacks.push(() => bind(plaintypedinput, "value", plaintypedinput_value_binding));
      binding_callbacks.push(() => bind(plaintypedinput, "type", plaintypedinput_type_binding));
      binding_callbacks.push(() => bind(plaintypedinput, "types", plaintypedinput_types_binding));
      binding_callbacks.push(() => bind(plaintypedinput, "label", plaintypedinput_label_binding));
      binding_callbacks.push(() => bind(plaintypedinput, "disabled", plaintypedinput_disabled_binding));
      plaintypedinput.$on("change", /*change_handler*/ ctx[19]);
      plaintypedinput.$on("mouseenter", /*mouseenter_handler*/ ctx[20]);
      plaintypedinput.$on("mouseleave", /*mouseleave_handler*/ ctx[21]);

      return {
        c() {
          create_component(plaintypedinput.$$.fragment);
        },
        m(target, anchor) {
          mount_component(plaintypedinput, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          const plaintypedinput_changes = {};
          if (dirty[0] & /*icon*/ 512) plaintypedinput_changes.icon = /*icon*/ ctx[9];
          if (dirty[0] & /*id*/ 1024) plaintypedinput_changes.id = /*id*/ ctx[10];

          if (!updating_node && dirty[0] & /*node*/ 1) {
            updating_node = true;
            plaintypedinput_changes.node = /*node*/ ctx[0];
            add_flush_callback(() => updating_node = false);
          }

          if (!updating_prop && dirty[0] & /*prop*/ 2) {
            updating_prop = true;
            plaintypedinput_changes.prop = /*prop*/ ctx[1];
            add_flush_callback(() => updating_prop = false);
          }

          if (!updating_typeProp && dirty[0] & /*typeProp*/ 4) {
            updating_typeProp = true;
            plaintypedinput_changes.typeProp = /*typeProp*/ ctx[2];
            add_flush_callback(() => updating_typeProp = false);
          }

          if (!updating_value && dirty[0] & /*value*/ 8) {
            updating_value = true;
            plaintypedinput_changes.value = /*value*/ ctx[3];
            add_flush_callback(() => updating_value = false);
          }

          if (!updating_type && dirty[0] & /*type*/ 16) {
            updating_type = true;
            plaintypedinput_changes.type = /*type*/ ctx[4];
            add_flush_callback(() => updating_type = false);
          }

          if (!updating_types && dirty[0] & /*types*/ 32) {
            updating_types = true;
            plaintypedinput_changes.types = /*types*/ ctx[5];
            add_flush_callback(() => updating_types = false);
          }

          if (!updating_label && dirty[0] & /*label*/ 64) {
            updating_label = true;
            plaintypedinput_changes.label = /*label*/ ctx[6];
            add_flush_callback(() => updating_label = false);
          }

          if (!updating_disabled && dirty[0] & /*disabled*/ 256) {
            updating_disabled = true;
            plaintypedinput_changes.disabled = /*disabled*/ ctx[8];
            add_flush_callback(() => updating_disabled = false);
          }

          plaintypedinput.$set(plaintypedinput_changes);
        },
        i(local) {
          if (current) return;
          transition_in(plaintypedinput.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(plaintypedinput.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(plaintypedinput, detaching);
        }
      };
    }

// (14:4) <Row>
    function create_default_slot$4(ctx) {
      let plaintypedinput;
      let updating_node;
      let updating_prop;
      let updating_typeProp;
      let updating_value;
      let updating_type;
      let updating_types;
      let updating_label;
      let updating_disabled;
      let current;

      function plaintypedinput_node_binding_1(value) {
        /*plaintypedinput_node_binding_1*/ ctx[22](value);
      }

      function plaintypedinput_prop_binding_1(value) {
        /*plaintypedinput_prop_binding_1*/ ctx[23](value);
      }

      function plaintypedinput_typeProp_binding_1(value) {
        /*plaintypedinput_typeProp_binding_1*/ ctx[24](value);
      }

      function plaintypedinput_value_binding_1(value) {
        /*plaintypedinput_value_binding_1*/ ctx[25](value);
      }

      function plaintypedinput_type_binding_1(value) {
        /*plaintypedinput_type_binding_1*/ ctx[26](value);
      }

      function plaintypedinput_types_binding_1(value) {
        /*plaintypedinput_types_binding_1*/ ctx[27](value);
      }

      function plaintypedinput_label_binding_1(value) {
        /*plaintypedinput_label_binding_1*/ ctx[28](value);
      }

      function plaintypedinput_disabled_binding_1(value) {
        /*plaintypedinput_disabled_binding_1*/ ctx[29](value);
      }

      let plaintypedinput_props = {
        icon: /*icon*/ ctx[9],
        id: /*id*/ ctx[10],
        width: "70%"
      };

      if (/*node*/ ctx[0] !== void 0) {
        plaintypedinput_props.node = /*node*/ ctx[0];
      }

      if (/*prop*/ ctx[1] !== void 0) {
        plaintypedinput_props.prop = /*prop*/ ctx[1];
      }

      if (/*typeProp*/ ctx[2] !== void 0) {
        plaintypedinput_props.typeProp = /*typeProp*/ ctx[2];
      }

      if (/*value*/ ctx[3] !== void 0) {
        plaintypedinput_props.value = /*value*/ ctx[3];
      }

      if (/*type*/ ctx[4] !== void 0) {
        plaintypedinput_props.type = /*type*/ ctx[4];
      }

      if (/*types*/ ctx[5] !== void 0) {
        plaintypedinput_props.types = /*types*/ ctx[5];
      }

      if (/*label*/ ctx[6] !== void 0) {
        plaintypedinput_props.label = /*label*/ ctx[6];
      }

      if (/*disabled*/ ctx[8] !== void 0) {
        plaintypedinput_props.disabled = /*disabled*/ ctx[8];
      }

      plaintypedinput = new PlainTypedInput({ props: plaintypedinput_props });
      binding_callbacks.push(() => bind(plaintypedinput, "node", plaintypedinput_node_binding_1));
      binding_callbacks.push(() => bind(plaintypedinput, "prop", plaintypedinput_prop_binding_1));
      binding_callbacks.push(() => bind(plaintypedinput, "typeProp", plaintypedinput_typeProp_binding_1));
      binding_callbacks.push(() => bind(plaintypedinput, "value", plaintypedinput_value_binding_1));
      binding_callbacks.push(() => bind(plaintypedinput, "type", plaintypedinput_type_binding_1));
      binding_callbacks.push(() => bind(plaintypedinput, "types", plaintypedinput_types_binding_1));
      binding_callbacks.push(() => bind(plaintypedinput, "label", plaintypedinput_label_binding_1));
      binding_callbacks.push(() => bind(plaintypedinput, "disabled", plaintypedinput_disabled_binding_1));
      plaintypedinput.$on("change", /*change_handler_1*/ ctx[30]);
      plaintypedinput.$on("mouseenter", /*mouseenter_handler_1*/ ctx[31]);
      plaintypedinput.$on("mouseleave", /*mouseleave_handler_1*/ ctx[32]);

      return {
        c() {
          create_component(plaintypedinput.$$.fragment);
        },
        m(target, anchor) {
          mount_component(plaintypedinput, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          const plaintypedinput_changes = {};
          if (dirty[0] & /*icon*/ 512) plaintypedinput_changes.icon = /*icon*/ ctx[9];
          if (dirty[0] & /*id*/ 1024) plaintypedinput_changes.id = /*id*/ ctx[10];

          if (!updating_node && dirty[0] & /*node*/ 1) {
            updating_node = true;
            plaintypedinput_changes.node = /*node*/ ctx[0];
            add_flush_callback(() => updating_node = false);
          }

          if (!updating_prop && dirty[0] & /*prop*/ 2) {
            updating_prop = true;
            plaintypedinput_changes.prop = /*prop*/ ctx[1];
            add_flush_callback(() => updating_prop = false);
          }

          if (!updating_typeProp && dirty[0] & /*typeProp*/ 4) {
            updating_typeProp = true;
            plaintypedinput_changes.typeProp = /*typeProp*/ ctx[2];
            add_flush_callback(() => updating_typeProp = false);
          }

          if (!updating_value && dirty[0] & /*value*/ 8) {
            updating_value = true;
            plaintypedinput_changes.value = /*value*/ ctx[3];
            add_flush_callback(() => updating_value = false);
          }

          if (!updating_type && dirty[0] & /*type*/ 16) {
            updating_type = true;
            plaintypedinput_changes.type = /*type*/ ctx[4];
            add_flush_callback(() => updating_type = false);
          }

          if (!updating_types && dirty[0] & /*types*/ 32) {
            updating_types = true;
            plaintypedinput_changes.types = /*types*/ ctx[5];
            add_flush_callback(() => updating_types = false);
          }

          if (!updating_label && dirty[0] & /*label*/ 64) {
            updating_label = true;
            plaintypedinput_changes.label = /*label*/ ctx[6];
            add_flush_callback(() => updating_label = false);
          }

          if (!updating_disabled && dirty[0] & /*disabled*/ 256) {
            updating_disabled = true;
            plaintypedinput_changes.disabled = /*disabled*/ ctx[8];
            add_flush_callback(() => updating_disabled = false);
          }

          plaintypedinput.$set(plaintypedinput_changes);
        },
        i(local) {
          if (current) return;
          transition_in(plaintypedinput.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(plaintypedinput.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(plaintypedinput, detaching);
        }
      };
    }

    function create_fragment$5(ctx) {
      let current_block_type_index;
      let if_block;
      let if_block_anchor;
      let current;
      const if_block_creators = [create_if_block$5, create_else_block$2];
      const if_blocks = [];

      function select_block_type(ctx, dirty) {
        if (/*inline*/ ctx[7]) return 0;
        return 1;
      }

      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

      return {
        c() {
          if_block.c();
          if_block_anchor = empty();
        },
        m(target, anchor) {
          if_blocks[current_block_type_index].m(target, anchor);
          insert(target, if_block_anchor, anchor);
          current = true;
        },
        p(ctx, dirty) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();

            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });

            check_outros();
            if_block = if_blocks[current_block_type_index];

            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            } else {
              if_block.p(ctx, dirty);
            }

            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        },
        i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o(local) {
          transition_out(if_block);
          current = false;
        },
        d(detaching) {
          if_blocks[current_block_type_index].d(detaching);
          if (detaching) detach(if_block_anchor);
        }
      };
    }

    function instance$5($$self, $$props, $$invalidate) {
      let { node } = $$props,
        { prop } = $$props,
        { typeProp } = $$props,
        { value } = $$props,
        { type } = $$props,
        { types } = $$props,
        { icon } = $$props,
        { label } = $$props,
        { id } = $$props,
        { inline = false } = $$props,
        { disabled = false } = $$props;

      inline = getBooleanFrom(inline);

      function plaintypedinput_node_binding(value) {
        node = value;
        $$invalidate(0, node);
      }

      function plaintypedinput_prop_binding(value) {
        prop = value;
        $$invalidate(1, prop);
      }

      function plaintypedinput_typeProp_binding(value) {
        typeProp = value;
        $$invalidate(2, typeProp);
      }

      function plaintypedinput_value_binding(value$1) {
        value = value$1;
        $$invalidate(3, value);
      }

      function plaintypedinput_type_binding(value) {
        type = value;
        $$invalidate(4, type);
      }

      function plaintypedinput_types_binding(value) {
        types = value;
        $$invalidate(5, types);
      }

      function plaintypedinput_label_binding(value) {
        label = value;
        $$invalidate(6, label);
      }

      function plaintypedinput_disabled_binding(value) {
        disabled = value;
        $$invalidate(8, disabled);
      }

      function change_handler(event) {
        bubble($$self, event);
      }

      function mouseenter_handler(event) {
        bubble($$self, event);
      }

      function mouseleave_handler(event) {
        bubble($$self, event);
      }

      function plaintypedinput_node_binding_1(value) {
        node = value;
        $$invalidate(0, node);
      }

      function plaintypedinput_prop_binding_1(value) {
        prop = value;
        $$invalidate(1, prop);
      }

      function plaintypedinput_typeProp_binding_1(value) {
        typeProp = value;
        $$invalidate(2, typeProp);
      }

      function plaintypedinput_value_binding_1(value$1) {
        value = value$1;
        $$invalidate(3, value);
      }

      function plaintypedinput_type_binding_1(value) {
        type = value;
        $$invalidate(4, type);
      }

      function plaintypedinput_types_binding_1(value) {
        types = value;
        $$invalidate(5, types);
      }

      function plaintypedinput_label_binding_1(value) {
        label = value;
        $$invalidate(6, label);
      }

      function plaintypedinput_disabled_binding_1(value) {
        disabled = value;
        $$invalidate(8, disabled);
      }

      function change_handler_1(event) {
        bubble($$self, event);
      }

      function mouseenter_handler_1(event) {
        bubble($$self, event);
      }

      function mouseleave_handler_1(event) {
        bubble($$self, event);
      }

      $$self.$$set = $$props => {
        if ("node" in $$props) $$invalidate(0, node = $$props.node);
        if ("prop" in $$props) $$invalidate(1, prop = $$props.prop);
        if ("typeProp" in $$props) $$invalidate(2, typeProp = $$props.typeProp);
        if ("value" in $$props) $$invalidate(3, value = $$props.value);
        if ("type" in $$props) $$invalidate(4, type = $$props.type);
        if ("types" in $$props) $$invalidate(5, types = $$props.types);
        if ("icon" in $$props) $$invalidate(9, icon = $$props.icon);
        if ("label" in $$props) $$invalidate(6, label = $$props.label);
        if ("id" in $$props) $$invalidate(10, id = $$props.id);
        if ("inline" in $$props) $$invalidate(7, inline = $$props.inline);
        if ("disabled" in $$props) $$invalidate(8, disabled = $$props.disabled);
      };

      return [
        node,
        prop,
        typeProp,
        value,
        type,
        types,
        label,
        inline,
        disabled,
        icon,
        id,
        plaintypedinput_node_binding,
        plaintypedinput_prop_binding,
        plaintypedinput_typeProp_binding,
        plaintypedinput_value_binding,
        plaintypedinput_type_binding,
        plaintypedinput_types_binding,
        plaintypedinput_label_binding,
        plaintypedinput_disabled_binding,
        change_handler,
        mouseenter_handler,
        mouseleave_handler,
        plaintypedinput_node_binding_1,
        plaintypedinput_prop_binding_1,
        plaintypedinput_typeProp_binding_1,
        plaintypedinput_value_binding_1,
        plaintypedinput_type_binding_1,
        plaintypedinput_types_binding_1,
        plaintypedinput_label_binding_1,
        plaintypedinput_disabled_binding_1,
        change_handler_1,
        mouseenter_handler_1,
        mouseleave_handler_1
      ];
    }

    class TypedInput extends SvelteComponent {
      constructor(options) {
        super();

        init(
          this,
          options,
          instance$5,
          create_fragment$5,
          safe_not_equal,
          {
            node: 0,
            prop: 1,
            typeProp: 2,
            value: 3,
            type: 4,
            types: 5,
            icon: 9,
            label: 6,
            id: 10,
            inline: 7,
            disabled: 8
          },
          [-1, -1]
        );
      }
    }

    /* node_modules/svelte-integration-red/components/Button.svelte generated by Svelte v3.35.0 */

    function create_if_block$4(ctx) {
      let i;
      let i_class_value;
      let t;

      return {
        c() {
          i = element("i");
          t = space();
          attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[2]);
        },
        m(target, anchor) {
          insert(target, i, anchor);
          insert(target, t, anchor);
        },
        p(ctx, dirty) {
          if (dirty & /*icon*/ 4 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[2])) {
            attr(i, "class", i_class_value);
          }
        },
        d(detaching) {
          if (detaching) detach(i);
          if (detaching) detach(t);
        }
      };
    }

    function create_fragment$4(ctx) {
      let button;
      let t_value = (/*label*/ ctx[3] || "") + "";
      let t;
      let mounted;
      let dispose;
      let if_block = /*icon*/ ctx[2] && create_if_block$4(ctx);

      return {
        c() {
          button = element("button");
          if (if_block) if_block.c();
          t = text(t_value);
          attr(button, "style", /*style*/ ctx[4]);
          button.disabled = /*disabled*/ ctx[1];
          attr(button, "type", "button");
          attr(button, "class", "red-ui-button");
          toggle_class(button, "red-ui-button-small", /*small*/ ctx[0]);
        },
        m(target, anchor) {
          insert(target, button, anchor);
          if (if_block) if_block.m(button, null);
          append(button, t);

          if (!mounted) {
            dispose = listen(button, "click", /*clickHandler*/ ctx[5]);
            mounted = true;
          }
        },
        p(ctx, [dirty]) {
          if (/*icon*/ ctx[2]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block$4(ctx);
              if_block.c();
              if_block.m(button, t);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }

          if (dirty & /*label*/ 8 && t_value !== (t_value = (/*label*/ ctx[3] || "") + "")) set_data(t, t_value);

          if (dirty & /*style*/ 16) {
            attr(button, "style", /*style*/ ctx[4]);
          }

          if (dirty & /*disabled*/ 2) {
            button.disabled = /*disabled*/ ctx[1];
          }

          if (dirty & /*small*/ 1) {
            toggle_class(button, "red-ui-button-small", /*small*/ ctx[0]);
          }
        },
        i: noop,
        o: noop,
        d(detaching) {
          if (detaching) detach(button);
          if (if_block) if_block.d();
          mounted = false;
          dispose();
        }
      };
    }

    function instance$4($$self, $$props, $$invalidate) {
      let { icon } = $$props,
        { label } = $$props,
        { small = false } = $$props,
        { disabled = false } = $$props,
        { style } = $$props;

      small = getBooleanFrom(small);
      disabled = getBooleanFrom(disabled);
      const dispatch = createEventDispatcher();

      function clickHandler(event) {
        dispatch("click", event.details);
      }

      $$self.$$set = $$props => {
        if ("icon" in $$props) $$invalidate(2, icon = $$props.icon);
        if ("label" in $$props) $$invalidate(3, label = $$props.label);
        if ("small" in $$props) $$invalidate(0, small = $$props.small);
        if ("disabled" in $$props) $$invalidate(1, disabled = $$props.disabled);
        if ("style" in $$props) $$invalidate(4, style = $$props.style);
      };

      return [small, disabled, icon, label, style, clickHandler];
    }

    class Button extends SvelteComponent {
      constructor(options) {
        super();

        init(this, options, instance$4, create_fragment$4, safe_not_equal, {
          icon: 2,
          label: 3,
          small: 0,
          disabled: 1,
          style: 4
        });
      }
    }

    /* node_modules/svelte-integration-red/components/EditableList.svelte generated by Svelte v3.35.0 */

    function add_css$3() {
      var style = element("style");
      style.id = "svelte-m977kl-style";
      style.textContent = ".disabled.svelte-m977kl{pointer-events:none}";
      append(document.head, style);
    }

    function get_each_context$2(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[15] = list[i];
      child_ctx[17] = i;
      return child_ctx;
    }

    const get_default_slot_changes = dirty => ({
      element: dirty & /*elements*/ 1,
      index: dirty & /*elements*/ 1
    });

    const get_default_slot_context = ctx => ({
      element: /*element*/ ctx[15],
      index: /*index*/ ctx[17]
    });

// (53:4) {#if label}
    function create_if_block_3$2(ctx) {
      let label_1;
      let t0;
      let t1;
      let label_1_for_value;
      let if_block = /*icon*/ ctx[7] && create_if_block_4$2(ctx);

      return {
        c() {
          label_1 = element("label");
          if (if_block) if_block.c();
          t0 = space();
          t1 = text(/*label*/ ctx[8]);
          attr(label_1, "for", label_1_for_value = "node-input-" + /*id*/ ctx[5] + "-container");
          set_style(label_1, "width", "auto");
        },
        m(target, anchor) {
          insert(target, label_1, anchor);
          if (if_block) if_block.m(label_1, null);
          append(label_1, t0);
          append(label_1, t1);
        },
        p(ctx, dirty) {
          if (/*icon*/ ctx[7]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block_4$2(ctx);
              if_block.c();
              if_block.m(label_1, t0);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }

          if (dirty & /*label*/ 256) set_data(t1, /*label*/ ctx[8]);

          if (dirty & /*id*/ 32 && label_1_for_value !== (label_1_for_value = "node-input-" + /*id*/ ctx[5] + "-container")) {
            attr(label_1, "for", label_1_for_value);
          }
        },
        d(detaching) {
          if (detaching) detach(label_1);
          if (if_block) if_block.d();
        }
      };
    }

// (54:68) {#if icon}
    function create_if_block_4$2(ctx) {
      let i;
      let i_class_value;

      return {
        c() {
          i = element("i");
          attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[7] + " svelte-m977kl");
        },
        m(target, anchor) {
          insert(target, i, anchor);
        },
        p(ctx, dirty) {
          if (dirty & /*icon*/ 128 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[7] + " svelte-m977kl")) {
            attr(i, "class", i_class_value);
          }
        },
        d(detaching) {
          if (detaching) detach(i);
        }
      };
    }

// (62:12) {#if sortable}
    function create_if_block_2$2(ctx) {
      let i;

      return {
        c() {
          i = element("i");
          attr(i, "class", "red-ui-editableList-item-handle fa fa-bars svelte-m977kl");
          toggle_class(i, "disabled", /*disabled*/ ctx[4]);
        },
        m(target, anchor) {
          insert(target, i, anchor);
        },
        p(ctx, dirty) {
          if (dirty & /*disabled*/ 16) {
            toggle_class(i, "disabled", /*disabled*/ ctx[4]);
          }
        },
        d(detaching) {
          if (detaching) detach(i);
        }
      };
    }

// (65:12) {#if removable}
    function create_if_block_1$3(ctx) {
      let div;
      let button;
      let current;

      function click_handler() {
        return /*click_handler*/ ctx[12](/*index*/ ctx[17]);
      }

      button = new Button({
        props: {
          small: true,
          class: "red-ui-editableList-item-remove",
          icon: "remove",
          disabled: /*disabled*/ ctx[4]
        }
      });

      button.$on("click", click_handler);

      return {
        c() {
          div = element("div");
          create_component(button.$$.fragment);
          attr(div, "class", "red-ui-editableList-item-remove");
        },
        m(target, anchor) {
          insert(target, div, anchor);
          mount_component(button, div, null);
          current = true;
        },
        p(new_ctx, dirty) {
          ctx = new_ctx;
          const button_changes = {};
          if (dirty & /*disabled*/ 16) button_changes.disabled = /*disabled*/ ctx[4];
          button.$set(button_changes);
        },
        i(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          if (detaching) detach(div);
          destroy_component(button);
        }
      };
    }

// (57:8) {#each elements as element, index (element.id || index)}
    function create_each_block$2(key_1, ctx) {
      let li;
      let div;
      let t0;
      let t1;
      let t2;
      let li_id_value;
      let current;
      const default_slot_template = /*#slots*/ ctx[11].default;
      const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], get_default_slot_context);
      let if_block0 = /*sortable*/ ctx[2] && create_if_block_2$2(ctx);
      let if_block1 = /*removable*/ ctx[3] && create_if_block_1$3(ctx);

      return {
        key: key_1,
        first: null,
        c() {
          li = element("li");
          div = element("div");
          if (default_slot) default_slot.c();
          t0 = space();
          if (if_block0) if_block0.c();
          t1 = space();
          if (if_block1) if_block1.c();
          t2 = space();
          attr(div, "class", "red-ui-editableList-item-content");
          set_style(div, "overflow", "hidden");
          set_style(div, "white-space", "nowrap");
          attr(li, "id", li_id_value = /*index*/ ctx[17]);
          toggle_class(li, "red-ui-editableList-item-sortable", /*sortable*/ ctx[2]);
          toggle_class(li, "red-ui-editableList-item-removable", /*removable*/ ctx[3]);
          this.first = li;
        },
        m(target, anchor) {
          insert(target, li, anchor);
          append(li, div);

          if (default_slot) {
            default_slot.m(div, null);
          }

          append(li, t0);
          if (if_block0) if_block0.m(li, null);
          append(li, t1);
          if (if_block1) if_block1.m(li, null);
          append(li, t2);
          current = true;
        },
        p(new_ctx, dirty) {
          ctx = new_ctx;

          if (default_slot) {
            if (default_slot.p && dirty & /*$$scope, elements*/ 8193) {
              update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[13], dirty, get_default_slot_changes, get_default_slot_context);
            }
          }

          if (/*sortable*/ ctx[2]) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_2$2(ctx);
              if_block0.c();
              if_block0.m(li, t1);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          if (/*removable*/ ctx[3]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty & /*removable*/ 8) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_1$3(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(li, t2);
            }
          } else if (if_block1) {
            group_outros();

            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });

            check_outros();
          }

          if (!current || dirty & /*elements*/ 1 && li_id_value !== (li_id_value = /*index*/ ctx[17])) {
            attr(li, "id", li_id_value);
          }

          if (dirty & /*sortable*/ 4) {
            toggle_class(li, "red-ui-editableList-item-sortable", /*sortable*/ ctx[2]);
          }

          if (dirty & /*removable*/ 8) {
            toggle_class(li, "red-ui-editableList-item-removable", /*removable*/ ctx[3]);
          }
        },
        i(local) {
          if (current) return;
          transition_in(default_slot, local);
          transition_in(if_block1);
          current = true;
        },
        o(local) {
          transition_out(default_slot, local);
          transition_out(if_block1);
          current = false;
        },
        d(detaching) {
          if (detaching) detach(li);
          if (default_slot) default_slot.d(detaching);
          if (if_block0) if_block0.d();
          if (if_block1) if_block1.d();
        }
      };
    }

// (73:4) {#if addButton}
    function create_if_block$3(ctx) {
      let button;
      let current;

      button = new Button({
        props: {
          style: "margin-top: 6px;",
          icon: "plus",
          disabled: /*disabled*/ ctx[4],
          label: " " + RED._("editableList.add"),
          small: true
        }
      });

      button.$on("click", /*addHandler*/ ctx[9]);

      return {
        c() {
          create_component(button.$$.fragment);
        },
        m(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          const button_changes = {};
          if (dirty & /*disabled*/ 16) button_changes.disabled = /*disabled*/ ctx[4];
          button.$set(button_changes);
        },
        i(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(button, detaching);
        }
      };
    }

// (52:0) <Row>
    function create_default_slot$3(ctx) {
      let t0;
      let ol;
      let each_blocks = [];
      let each_1_lookup = new Map();
      let ol_id_value;
      let ol_style_value;
      let t1;
      let if_block1_anchor;
      let current;
      let if_block0 = /*label*/ ctx[8] && create_if_block_3$2(ctx);
      let each_value = /*elements*/ ctx[0];
      const get_key = ctx => /*element*/ ctx[15].id || /*index*/ ctx[17];

      for (let i = 0; i < each_value.length; i += 1) {
        let child_ctx = get_each_context$2(ctx, each_value, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
      }

      let if_block1 = /*addButton*/ ctx[1] && create_if_block$3(ctx);

      return {
        c() {
          if (if_block0) if_block0.c();
          t0 = space();
          ol = element("ol");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t1 = space();
          if (if_block1) if_block1.c();
          if_block1_anchor = empty();
          attr(ol, "id", ol_id_value = "node-input-" + /*id*/ ctx[5] + "-container");
          attr(ol, "style", ol_style_value = "min-height: 100px; " + /*style*/ ctx[6]);
        },
        m(target, anchor) {
          if (if_block0) if_block0.m(target, anchor);
          insert(target, t0, anchor);
          insert(target, ol, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ol, null);
          }

          insert(target, t1, anchor);
          if (if_block1) if_block1.m(target, anchor);
          insert(target, if_block1_anchor, anchor);
          current = true;
        },
        p(ctx, dirty) {
          if (/*label*/ ctx[8]) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_3$2(ctx);
              if_block0.c();
              if_block0.m(t0.parentNode, t0);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          if (dirty & /*elements, sortable, removable, disabled, removeHandler, $$scope*/ 9245) {
            each_value = /*elements*/ ctx[0];
            group_outros();
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ol, outro_and_destroy_block, create_each_block$2, null, get_each_context$2);
            check_outros();
          }

          if (!current || dirty & /*id*/ 32 && ol_id_value !== (ol_id_value = "node-input-" + /*id*/ ctx[5] + "-container")) {
            attr(ol, "id", ol_id_value);
          }

          if (!current || dirty & /*style*/ 64 && ol_style_value !== (ol_style_value = "min-height: 100px; " + /*style*/ ctx[6])) {
            attr(ol, "style", ol_style_value);
          }

          if (/*addButton*/ ctx[1]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty & /*addButton*/ 2) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block$3(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
            }
          } else if (if_block1) {
            group_outros();

            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });

            check_outros();
          }
        },
        i(local) {
          if (current) return;

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          transition_in(if_block1);
          current = true;
        },
        o(local) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          transition_out(if_block1);
          current = false;
        },
        d(detaching) {
          if (if_block0) if_block0.d(detaching);
          if (detaching) detach(t0);
          if (detaching) detach(ol);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }

          if (detaching) detach(t1);
          if (if_block1) if_block1.d(detaching);
          if (detaching) detach(if_block1_anchor);
        }
      };
    }

    function create_fragment$3(ctx) {
      let row;
      let current;

      row = new Row({
        props: {
          $$slots: { default: [create_default_slot$3] },
          $$scope: { ctx }
        }
      });

      return {
        c() {
          create_component(row.$$.fragment);
        },
        m(target, anchor) {
          mount_component(row, target, anchor);
          current = true;
        },
        p(ctx, [dirty]) {
          const row_changes = {};

          if (dirty & /*$$scope, disabled, addButton, id, style, elements, sortable, removable, label, icon*/ 8703) {
            row_changes.$$scope = { dirty, ctx };
          }

          row.$set(row_changes);
        },
        i(local) {
          if (current) return;
          transition_in(row.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(row.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(row, detaching);
        }
      };
    }

    function instance$3($$self, $$props, $$invalidate) {
      let { $$slots: slots = {}, $$scope } = $$props;
      let { id = getId() } = $$props;

      let { elements } = $$props,
        { addButton = false } = $$props,
        { sortable = false } = $$props,
        { removable = false } = $$props,
        { style } = $$props,
        { icon } = $$props,
        { label = "" } = $$props,
        { disabled = false } = $$props;

      addButton = getBooleanFrom(addButton);
      sortable = getBooleanFrom(sortable);
      removable = getBooleanFrom(removable);
      disabled = getBooleanFrom(disabled);
      const dispatch = createEventDispatcher();

      onMount(() => {
        window.$("#node-input-" + id + "-container").editableList({
          addButton: false,
          sortable,
          sortItems: items => {
            const before = [...elements];
            const orderedElements = [];
            const childrenInOriginalOrder = [];

            for (let i = 0; i < items.length; i++) {
              orderedElements[i] = elements[items[i].prevObject[0].id];
              childrenInOriginalOrder[items[i].prevObject[0].id] = items[i].prevObject[0];
            }

            // Hack: Reorder elements
            // This allows us to use the built-in sortable behaviour of Node-RED / jQuery
            // while preserving a correct rendering through Svelte
            const container = window.$("#node-input-" + id + "-container");

            container.append(childrenInOriginalOrder);
            $$invalidate(0, elements = orderedElements);
            dispatch("sort", { before, after: orderedElements });
          }
        });
      });

      function addHandler() {
        dispatch("add", { index: elements.length });
      }

      function removeHandler(index) {
        const removed = elements[index];
        $$invalidate(0, elements = [...elements.slice(0, index), ...elements.slice(index + 1)]);
        dispatch("remove", { removed });
      }

      const click_handler = index => removeHandler(index);

      $$self.$$set = $$props => {
        if ("id" in $$props) $$invalidate(5, id = $$props.id);
        if ("elements" in $$props) $$invalidate(0, elements = $$props.elements);
        if ("addButton" in $$props) $$invalidate(1, addButton = $$props.addButton);
        if ("sortable" in $$props) $$invalidate(2, sortable = $$props.sortable);
        if ("removable" in $$props) $$invalidate(3, removable = $$props.removable);
        if ("style" in $$props) $$invalidate(6, style = $$props.style);
        if ("icon" in $$props) $$invalidate(7, icon = $$props.icon);
        if ("label" in $$props) $$invalidate(8, label = $$props.label);
        if ("disabled" in $$props) $$invalidate(4, disabled = $$props.disabled);
        if ("$$scope" in $$props) $$invalidate(13, $$scope = $$props.$$scope);
      };

      return [
        elements,
        addButton,
        sortable,
        removable,
        disabled,
        id,
        style,
        icon,
        label,
        addHandler,
        removeHandler,
        slots,
        click_handler,
        $$scope
      ];
    }

    class EditableList extends SvelteComponent {
      constructor(options) {
        super();
        if (!document.getElementById("svelte-m977kl-style")) add_css$3();

        init(this, options, instance$3, create_fragment$3, safe_not_equal, {
          id: 5,
          elements: 0,
          addButton: 1,
          sortable: 2,
          removable: 3,
          style: 6,
          icon: 7,
          label: 8,
          disabled: 4
        });
      }
    }

    /* node_modules/svelte-integration-red/components/Select.svelte generated by Svelte v3.35.0 */

    function add_css$2() {
      var style = element("style");
      style.id = "svelte-m977kl-style";
      style.textContent = ".disabled.svelte-m977kl{pointer-events:none}";
      append(document.head, style);
    }

// (36:33) {#if icon}
    function create_if_block_1$2(ctx) {
      let i;
      let i_class_value;

      return {
        c() {
          i = element("i");
          attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[5] + " svelte-m977kl");
        },
        m(target, anchor) {
          insert(target, i, anchor);
        },
        p(ctx, dirty) {
          if (dirty & /*icon*/ 32 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[5] + " svelte-m977kl")) {
            attr(i, "class", i_class_value);
          }
        },
        d(detaching) {
          if (detaching) detach(i);
        }
      };
    }

// (43:8) {#if button !== false}
    function create_if_block$2(ctx) {
      let a;
      let i;
      let i_class_value;
      let a_id_value;
      let mounted;
      let dispose;

      return {
        c() {
          a = element("a");
          i = element("i");

          attr(i, "class", i_class_value = "fa fa-" + (typeof /*button*/ ctx[6] === "string"
            ? /*button*/ ctx[6]
            : "plus") + " svelte-m977kl");

          attr(a, "id", a_id_value = "node-input-" + /*id*/ ctx[3] + "-action");
          attr(a, "class", "red-ui-button svelte-m977kl");
          set_style(a, "position", "absolute");
          set_style(a, "right", "0px");
          set_style(a, "top", "0px");
          toggle_class(a, "disabled", /*disabled*/ ctx[7]);
        },
        m(target, anchor) {
          insert(target, a, anchor);
          append(a, i);

          if (!mounted) {
            dispose = listen(a, "click", /*click_handler*/ ctx[13]);
            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (dirty & /*button*/ 64 && i_class_value !== (i_class_value = "fa fa-" + (typeof /*button*/ ctx[6] === "string"
            ? /*button*/ ctx[6]
            : "plus") + " svelte-m977kl")) {
            attr(i, "class", i_class_value);
          }

          if (dirty & /*id*/ 8 && a_id_value !== (a_id_value = "node-input-" + /*id*/ ctx[3] + "-action")) {
            attr(a, "id", a_id_value);
          }

          if (dirty & /*disabled*/ 128) {
            toggle_class(a, "disabled", /*disabled*/ ctx[7]);
          }
        },
        d(detaching) {
          if (detaching) detach(a);
          mounted = false;
          dispose();
        }
      };
    }

// (35:0) <Row style="{button ? '' : 'display: flex; align-items: baseline;'}">
    function create_default_slot$2(ctx) {
      let label_1;
      let t0;
      let t1;
      let label_1_for_value;
      let t2;
      let div1;
      let div0;
      let select;
      let select_id_value;
      let select_placeholder_value;
      let div0_style_value;
      let t3;
      let current;
      let mounted;
      let dispose;
      let if_block0 = /*icon*/ ctx[5] && create_if_block_1$2(ctx);
      const default_slot_template = /*#slots*/ ctx[10].default;
      const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);
      let if_block1 = /*button*/ ctx[6] !== false && create_if_block$2(ctx);

      return {
        c() {
          label_1 = element("label");
          if (if_block0) if_block0.c();
          t0 = space();
          t1 = text(/*label*/ ctx[2]);
          t2 = space();
          div1 = element("div");
          div0 = element("div");
          select = element("select");
          if (default_slot) default_slot.c();
          t3 = space();
          if (if_block1) if_block1.c();
          attr(label_1, "for", label_1_for_value = "node-input-" + /*id*/ ctx[3]);
          set_style(select, "width", "100%");
          attr(select, "id", select_id_value = "node-input-" + /*id*/ ctx[3]);
          select.disabled = /*disabled*/ ctx[7];
          attr(select, "placeholder", select_placeholder_value = /*node*/ ctx[1] && /*defaults*/ ctx[8][/*prop*/ ctx[4]].label || "");
          if (/*value*/ ctx[0] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[14].call(select));

          attr(div0, "style", div0_style_value = "" + ((/*button*/ ctx[6]
            ? "position: absolute; left: 0px;"
            : "position: relative;left: 4px;") + " right: 40px;"));

          set_style(div1, "display", "inline-block");
          set_style(div1, "position", "relative");
          set_style(div1, "width", "70%");
          set_style(div1, "height", "20px");
        },
        m(target, anchor) {
          insert(target, label_1, anchor);
          if (if_block0) if_block0.m(label_1, null);
          append(label_1, t0);
          append(label_1, t1);
          insert(target, t2, anchor);
          insert(target, div1, anchor);
          append(div1, div0);
          append(div0, select);

          if (default_slot) {
            default_slot.m(select, null);
          }

          select_option(select, /*value*/ ctx[0]);
          append(div1, t3);
          if (if_block1) if_block1.m(div1, null);
          current = true;

          if (!mounted) {
            dispose = [
              listen(select, "change", /*select_change_handler*/ ctx[14]),
              listen(div1, "mouseenter", /*mouseenter_handler*/ ctx[11]),
              listen(div1, "mouseleave", /*mouseleave_handler*/ ctx[12])
            ];

            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (/*icon*/ ctx[5]) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_1$2(ctx);
              if_block0.c();
              if_block0.m(label_1, t0);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          if (!current || dirty & /*label*/ 4) set_data(t1, /*label*/ ctx[2]);

          if (!current || dirty & /*id*/ 8 && label_1_for_value !== (label_1_for_value = "node-input-" + /*id*/ ctx[3])) {
            attr(label_1, "for", label_1_for_value);
          }

          if (default_slot) {
            if (default_slot.p && dirty & /*$$scope*/ 32768) {
              update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[15], dirty, null, null);
            }
          }

          if (!current || dirty & /*id*/ 8 && select_id_value !== (select_id_value = "node-input-" + /*id*/ ctx[3])) {
            attr(select, "id", select_id_value);
          }

          if (!current || dirty & /*disabled*/ 128) {
            select.disabled = /*disabled*/ ctx[7];
          }

          if (!current || dirty & /*node, prop*/ 18 && select_placeholder_value !== (select_placeholder_value = /*node*/ ctx[1] && /*defaults*/ ctx[8][/*prop*/ ctx[4]].label || "")) {
            attr(select, "placeholder", select_placeholder_value);
          }

          if (dirty & /*value*/ 1) {
            select_option(select, /*value*/ ctx[0]);
          }

          if (!current || dirty & /*button*/ 64 && div0_style_value !== (div0_style_value = "" + ((/*button*/ ctx[6]
            ? "position: absolute; left: 0px;"
            : "position: relative;left: 4px;") + " right: 40px;"))) {
            attr(div0, "style", div0_style_value);
          }

          if (/*button*/ ctx[6] !== false) {
            if (if_block1) {
              if_block1.p(ctx, dirty);
            } else {
              if_block1 = create_if_block$2(ctx);
              if_block1.c();
              if_block1.m(div1, null);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }
        },
        i(local) {
          if (current) return;
          transition_in(default_slot, local);
          current = true;
        },
        o(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d(detaching) {
          if (detaching) detach(label_1);
          if (if_block0) if_block0.d();
          if (detaching) detach(t2);
          if (detaching) detach(div1);
          if (default_slot) default_slot.d(detaching);
          if (if_block1) if_block1.d();
          mounted = false;
          run_all(dispose);
        }
      };
    }

    function create_fragment$2(ctx) {
      let row;
      let current;

      row = new Row({
        props: {
          style: /*button*/ ctx[6]
            ? ""
            : "display: flex; align-items: baseline;",
          $$slots: { default: [create_default_slot$2] },
          $$scope: { ctx }
        }
      });

      return {
        c() {
          create_component(row.$$.fragment);
        },
        m(target, anchor) {
          mount_component(row, target, anchor);
          current = true;
        },
        p(ctx, [dirty]) {
          const row_changes = {};

          if (dirty & /*button*/ 64) row_changes.style = /*button*/ ctx[6]
            ? ""
            : "display: flex; align-items: baseline;";

          if (dirty & /*$$scope, id, disabled, button, node, prop, value, label, icon*/ 33023) {
            row_changes.$$scope = { dirty, ctx };
          }

          row.$set(row_changes);
        },
        i(local) {
          if (current) return;
          transition_in(row.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(row.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(row, detaching);
        }
      };
    }

    function instance$2($$self, $$props, $$invalidate) {
      let { $$slots: slots = {}, $$scope } = $$props;

      let { node } = $$props,
        { prop } = $$props,
        { value } = $$props,
        { icon } = $$props,
        { label } = $$props,
        { button = false } = $$props,
        { id } = $$props,
        { disabled = false } = $$props;

      if (!id) {
        id = getId(prop);
      }

      const dispatch = createEventDispatcher();
      const updateNode = typeof node !== "undefined";
      value = updateNode && node[prop] || value;
      let init = true;
      let defaults = node ? node._def.defaults : {};
      label = label || node && (defaults[prop] && defaults[prop].label || prop);

      function mouseenter_handler(event) {
        bubble($$self, event);
      }

      function mouseleave_handler(event) {
        bubble($$self, event);
      }

      function click_handler(event) {
        bubble($$self, event);
      }

      function select_change_handler() {
        value = select_value(this);
        $$invalidate(0, value);
      }

      $$self.$$set = $$props => {
        if ("node" in $$props) $$invalidate(1, node = $$props.node);
        if ("prop" in $$props) $$invalidate(4, prop = $$props.prop);
        if ("value" in $$props) $$invalidate(0, value = $$props.value);
        if ("icon" in $$props) $$invalidate(5, icon = $$props.icon);
        if ("label" in $$props) $$invalidate(2, label = $$props.label);
        if ("button" in $$props) $$invalidate(6, button = $$props.button);
        if ("id" in $$props) $$invalidate(3, id = $$props.id);
        if ("disabled" in $$props) $$invalidate(7, disabled = $$props.disabled);
        if ("$$scope" in $$props) $$invalidate(15, $$scope = $$props.$$scope);
      };

      $$self.$$.update = () => {
        if ($$self.$$.dirty & /*prop, value, init*/ 529) {
          {
            if (updateNode) {
              $$invalidate(1, node[prop] = value, node);
            }

            if (!init) {
              dispatch("change", { value });
            }

            $$invalidate(9, init = false);
          }
        }
      };

      return [
        value,
        node,
        label,
        id,
        prop,
        icon,
        button,
        disabled,
        defaults,
        init,
        slots,
        mouseenter_handler,
        mouseleave_handler,
        click_handler,
        select_change_handler,
        $$scope
      ];
    }

    class Select extends SvelteComponent {
      constructor(options) {
        super();
        if (!document.getElementById("svelte-m977kl-style")) add_css$2();

        init(this, options, instance$2, create_fragment$2, safe_not_equal, {
          node: 1,
          prop: 4,
          value: 0,
          icon: 5,
          label: 2,
          button: 6,
          id: 3,
          disabled: 7
        });
      }
    }

    async function getApiList (openApiUrl) {
      const url = encodeURI(openApiUrl);
      // server call
      return window.$.get('getNewOpenApiInfo?openApiUrl=' + url, function (response) {
        return response
      })
        .fail(function (message) {
          return message
        })
    }

    const getCorrectType = (param) => {
      const type = param?.schema?.type || param.type;
      if (type === 'boolean') return 'bool'
      if (type === 'integer') return 'num'
      if (param.name === 'Json Request Body' || param.name === 'body' || type === 'body' || type === 'object') return 'json'
      if (param?.items?.enum?.length > 0 || param?.schema?.enum?.length) return 'array'
      return 'str'
    };

    const getAllowedTypes = (input) => {
      let type;
      if (typeof input === 'string') type = input;
      else type = getCorrectType(input);
      if (type === 'bool') return ['bool', 'msg', 'flow', 'global']
      if (type === 'num') return ['num', 'jsonata', 'msg', 'flow', 'global']
      if (type === 'json') return ['json', 'jsonata', 'msg', 'flow', 'global']
      if (type === 'array') {
        const options = input?.items?.enum || input?.schema?.enum;
        return [{ value: 'select', label: 'Select', options: options }, 'str', 'msg', 'flow', 'global']
      }
      return ['str', 'json', 'jsonata', 'msg', 'flow', 'global']
    };

// is an object
    const sortKeys = (schema) => {
      let keys = null;
      if (schema?.properties) {
        // ordering keys helps later with svelte #each (first required then normal and sorted alphabetical)
        keys = Object.keys(schema.properties).sort();
        if (schema.required) {
          const notRequiredKeys = keys.filter(prop => !schema.required.includes(prop));
          keys = schema.required.sort().concat(notRequiredKeys.sort());
        }
      }
      return keys
    };
// is an array
    const orderRequired = (a, b) => {
      let comparison = 0;
      if (b.required) {
        comparison = 1;
      } else if (a.required) {
        comparison = -1;
      }
      return comparison
    };

    const createParameters = (node, operationData, oldParameters) => {
      // openApi 3 new body style with selection
      if (!operationData.parameters && operationData?.requestBody?.content) {
        const requestBody = operationData.requestBody;
        const content = requestBody.content;
        const keys = sortKeys(content[node.contentType].schema);
        if (content[node.contentType]) {
          node.parameters.push({
            id: 'requestBody',
            name: 'Request body',
            in: '',
            schema: content[node.contentType].schema || null,
            value: oldParameters?.[' Request body']?.value || '{}',
            required: !!requestBody?.required || false,
            isActive: !!requestBody?.required || oldParameters?.[' Request body']?.isActive || false,
            description: requestBody?.description || '-',
            type: oldParameters?.[' Request body']?.inputType || 'json',
            allowedTypes: getAllowedTypes('json'),
            keys
          });
        }
      } else {
        let parameters = operationData?.parameters?.sort(orderRequired);
        if (!parameters) parameters = [];
        parameters.forEach(param => {
          const keys = sortKeys(param.schema);
          node.parameters.push(
            {
              id: param.name + param.in,
              name: param.name,
              in: param.in,
              required: param.required,
              value: oldParameters?.[param.name + ' ' + param.in]?.value || '',
              isActive: !!param.required || oldParameters?.[param.name + ' ' + param.in]?.isActive || false,
              type: oldParameters?.[param.name + ' ' + param.in]?.inputType || getCorrectType(param), // selected type
              allowedTypes: getAllowedTypes(param),
              description: param.description || '-',
              schema: param.schema || null,
              keys
            }
          );
        });
      }
    };

    /* utils/JsonParamHelper.svelte generated by Svelte v3.35.0 */

    function add_css$1() {
      var style = element("style");
      style.id = "svelte-qzpchp-style";
      style.textContent = ".jsonObjectKeyList.svelte-qzpchp{margin-bottom:0px}.jsonKeys.svelte-qzpchp{display:none}";
      append(document.head, style);
    }

    function get_each_context$1(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[8] = list[i];
      return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[11] = list[i][0];
      child_ctx[12] = list[i][1];
      return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[11] = list[i][0];
      child_ctx[12] = list[i][1];
      return child_ctx;
    }

// (55:0) <Row>
    function create_default_slot$1(ctx) {
      let button0;
      let t0;
      let button1;
      let t1;
      let button2;
      let current;

      button0 = new Button({
        props: { icon: "show", label: /*label*/ ctx[2] }
      });

      button0.$on("click", /*click_handler*/ ctx[4]);

      button1 = new Button({
        props: { icon: "edit", label: "Set default" }
      });

      button1.$on("click", /*click_handler_1*/ ctx[5]);

      button2 = new Button({
        props: { icon: "edit", label: "Set required" }
      });

      button2.$on("click", /*click_handler_2*/ ctx[6]);

      return {
        c() {
          create_component(button0.$$.fragment);
          t0 = space();
          create_component(button1.$$.fragment);
          t1 = space();
          create_component(button2.$$.fragment);
        },
        m(target, anchor) {
          mount_component(button0, target, anchor);
          insert(target, t0, anchor);
          mount_component(button1, target, anchor);
          insert(target, t1, anchor);
          mount_component(button2, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          const button0_changes = {};
          if (dirty & /*label*/ 4) button0_changes.label = /*label*/ ctx[2];
          button0.$set(button0_changes);
        },
        i(local) {
          if (current) return;
          transition_in(button0.$$.fragment, local);
          transition_in(button1.$$.fragment, local);
          transition_in(button2.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(button0.$$.fragment, local);
          transition_out(button1.$$.fragment, local);
          transition_out(button2.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(button0, detaching);
          if (detaching) detach(t0);
          destroy_component(button1, detaching);
          if (detaching) detach(t1);
          destroy_component(button2, detaching);
        }
      };
    }

// (99:2) {:else}
    function create_else_block$1(ctx) {
      let t;

      return {
        c() {
          t = text("No properties defined.");
        },
        m(target, anchor) {
          insert(target, t, anchor);
        },
        p: noop,
        d(detaching) {
          if (detaching) detach(t);
        }
      };
    }

// (61:2) {#if param.schema && param.keys}
    function create_if_block$1(ctx) {
      let each_1_anchor;
      let each_value = /*param*/ ctx[0].keys;
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
      }

      return {
        c() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          each_1_anchor = empty();
        },
        m(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(target, anchor);
          }

          insert(target, each_1_anchor, anchor);
        },
        p(ctx, dirty) {
          if (dirty & /*Object, param*/ 1) {
            each_value = /*param*/ ctx[0].keys;
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$1(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$1(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }
        },
        d(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching) detach(each_1_anchor);
        }
      };
    }

// (68:10) {#if param.schema.properties[propKey].description}
    function create_if_block_5$1(ctx) {
      let div;
      let t0;
      let t1_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].description + "";
      let t1;

      return {
        c() {
          div = element("div");
          t0 = text("Description: ");
          t1 = text(t1_value);
        },
        m(target, anchor) {
          insert(target, div, anchor);
          append(div, t0);
          append(div, t1);
        },
        p(ctx, dirty) {
          if (dirty & /*param*/ 1 && t1_value !== (t1_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].description + "")) set_data(t1, t1_value);
        },
        d(detaching) {
          if (detaching) detach(div);
        }
      };
    }

// (71:10) {#if param.schema.properties[propKey].example}
    function create_if_block_4$1(ctx) {
      let div;
      let t0;
      let t1_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].example + "";
      let t1;

      return {
        c() {
          div = element("div");
          t0 = text("Example: ");
          t1 = text(t1_value);
        },
        m(target, anchor) {
          insert(target, div, anchor);
          append(div, t0);
          append(div, t1);
        },
        p(ctx, dirty) {
          if (dirty & /*param*/ 1 && t1_value !== (t1_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].example + "")) set_data(t1, t1_value);
        },
        d(detaching) {
          if (detaching) detach(div);
        }
      };
    }

// (82:119)
    function create_if_block_2$1(ctx) {
      let div1;
      let div0;
      let t0;
      let t1_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].items.type + "";
      let t1;
      let t2;
      let if_block = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].items.type === "object" && /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]]?.items?.properties && create_if_block_3$1(ctx);

      return {
        c() {
          div1 = element("div");
          div0 = element("div");
          t0 = text("Containing: ");
          t1 = text(t1_value);
          t2 = space();
          if (if_block) if_block.c();
        },
        m(target, anchor) {
          insert(target, div1, anchor);
          append(div1, div0);
          append(div0, t0);
          append(div0, t1);
          append(div1, t2);
          if (if_block) if_block.m(div1, null);
        },
        p(ctx, dirty) {
          if (dirty & /*param*/ 1 && t1_value !== (t1_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].items.type + "")) set_data(t1, t1_value);

          if (/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].items.type === "object" && /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]]?.items?.properties) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block_3$1(ctx);
              if_block.c();
              if_block.m(div1, null);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
        },
        d(detaching) {
          if (detaching) detach(div1);
          if (if_block) if_block.d();
        }
      };
    }

// (74:10) {#if param.schema.properties[propKey].type === "object"}
    function create_if_block_1$1(ctx) {
      let t0_value = "{" + "";
      let t0;
      let t1;
      let ul;
      let each_blocks = [];
      let each_1_lookup = new Map();
      let t2;
      let t3_value = "}" + "";
      let t3;
      let each_value_1 = Object.entries(/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].properties);
      const get_key = ctx => /*pKey*/ ctx[11];

      for (let i = 0; i < each_value_1.length; i += 1) {
        let child_ctx = get_each_context_1$1(ctx, each_value_1, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block_1$1(key, child_ctx));
      }

      return {
        c() {
          t0 = text(t0_value);
          t1 = space();
          ul = element("ul");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t2 = space();
          t3 = text(t3_value);
        },
        m(target, anchor) {
          insert(target, t0, anchor);
          insert(target, t1, anchor);
          insert(target, ul, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          insert(target, t2, anchor);
          insert(target, t3, anchor);
        },
        p(ctx, dirty) {
          if (dirty & /*Object, param*/ 1) {
            each_value_1 = Object.entries(/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].properties);
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, ul, destroy_block, create_each_block_1$1, null, get_each_context_1$1);
          }
        },
        d(detaching) {
          if (detaching) detach(t0);
          if (detaching) detach(t1);
          if (detaching) detach(ul);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }

          if (detaching) detach(t2);
          if (detaching) detach(t3);
        }
      };
    }

// (85:14) {#if param.schema.properties[propKey].items.type === "object" && param.schema.properties[propKey]?.items?.properties}
    function create_if_block_3$1(ctx) {
      let t0_value = "{" + "";
      let t0;
      let t1;
      let ul;
      let each_blocks = [];
      let each_1_lookup = new Map();
      let t2;
      let t3_value = "}" + "";
      let t3;
      let each_value_2 = Object.entries(/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].items.properties);
      const get_key = ctx => /*pKey*/ ctx[11];

      for (let i = 0; i < each_value_2.length; i += 1) {
        let child_ctx = get_each_context_2$1(ctx, each_value_2, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block_2$1(key, child_ctx));
      }

      return {
        c() {
          t0 = text(t0_value);
          t1 = space();
          ul = element("ul");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t2 = space();
          t3 = text(t3_value);
        },
        m(target, anchor) {
          insert(target, t0, anchor);
          insert(target, t1, anchor);
          insert(target, ul, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          insert(target, t2, anchor);
          insert(target, t3, anchor);
        },
        p(ctx, dirty) {
          if (dirty & /*Object, param*/ 1) {
            each_value_2 = Object.entries(/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].items.properties);
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_2, each_1_lookup, ul, destroy_block, create_each_block_2$1, null, get_each_context_2$1);
          }
        },
        d(detaching) {
          if (detaching) detach(t0);
          if (detaching) detach(t1);
          if (detaching) detach(ul);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }

          if (detaching) detach(t2);
          if (detaching) detach(t3);
        }
      };
    }

// (88:18) {#each Object.entries(param.schema.properties[propKey].items.properties) as [pKey, p] (pKey)}
    function create_each_block_2$1(key_1, ctx) {
      let p;
      let t0_value = /*pKey*/ ctx[11] + "";
      let t0;
      let t1;
      let t2_value = /*p*/ ctx[12].type + "";
      let t2;

      return {
        key: key_1,
        first: null,
        c() {
          p = element("p");
          t0 = text(t0_value);
          t1 = text(": ");
          t2 = text(t2_value);
          attr(p, "class", "jsonObjectKeyList svelte-qzpchp");
          this.first = p;
        },
        m(target, anchor) {
          insert(target, p, anchor);
          append(p, t0);
          append(p, t1);
          append(p, t2);
        },
        p(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty & /*param*/ 1 && t0_value !== (t0_value = /*pKey*/ ctx[11] + "")) set_data(t0, t0_value);
          if (dirty & /*param*/ 1 && t2_value !== (t2_value = /*p*/ ctx[12].type + "")) set_data(t2, t2_value);
        },
        d(detaching) {
          if (detaching) detach(p);
        }
      };
    }

// (77:14) {#each Object.entries(param.schema.properties[propKey].properties) as [pKey, p] (pKey)}
    function create_each_block_1$1(key_1, ctx) {
      let p;
      let t0_value = /*pKey*/ ctx[11] + "";
      let t0;
      let t1;
      let t2_value = /*p*/ ctx[12].type + "";
      let t2;

      return {
        key: key_1,
        first: null,
        c() {
          p = element("p");
          t0 = text(t0_value);
          t1 = text(": ");
          t2 = text(t2_value);
          attr(p, "class", "jsonObjectKeyList svelte-qzpchp");
          this.first = p;
        },
        m(target, anchor) {
          insert(target, p, anchor);
          append(p, t0);
          append(p, t1);
          append(p, t2);
        },
        p(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty & /*param*/ 1 && t0_value !== (t0_value = /*pKey*/ ctx[11] + "")) set_data(t0, t0_value);
          if (dirty & /*param*/ 1 && t2_value !== (t2_value = /*p*/ ctx[12].type + "")) set_data(t2, t2_value);
        },
        d(detaching) {
          if (detaching) detach(p);
        }
      };
    }

// (62:4) {#each param.keys as propKey}
    function create_each_block$1(ctx) {
      let ul;
      let li;
      let div;
      let t0_value = /*propKey*/ ctx[8] + "";
      let t0;
      let t1;
      let t2_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].type + "";
      let t2;
      let t3;
      let t4;
      let t5;
      let t6;

      function func(...args) {
        return /*func*/ ctx[7](/*propKey*/ ctx[8], ...args);
      }

      let if_block0 = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].description && create_if_block_5$1(ctx);
      let if_block1 = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].example && create_if_block_4$1(ctx);

      function select_block_type_1(ctx, dirty) {
        if (/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].type === "object") return create_if_block_1$1;
        if (/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].type === "array" && /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]]?.items?.type) return create_if_block_2$1;
      }

      let current_block_type = select_block_type_1(ctx);
      let if_block2 = current_block_type && current_block_type(ctx);

      return {
        c() {
          ul = element("ul");
          li = element("li");
          div = element("div");
          t0 = text(t0_value);
          t1 = text(": ");
          t2 = text(t2_value);
          t3 = space();
          if (if_block0) if_block0.c();
          t4 = space();
          if (if_block1) if_block1.c();
          t5 = space();
          if (if_block2) if_block2.c();
          t6 = space();
          toggle_class(div, "required", /*param*/ ctx[0].schema.required && /*param*/ ctx[0].schema.required.find(func));
        },
        m(target, anchor) {
          insert(target, ul, anchor);
          append(ul, li);
          append(li, div);
          append(div, t0);
          append(div, t1);
          append(div, t2);
          append(li, t3);
          if (if_block0) if_block0.m(li, null);
          append(li, t4);
          if (if_block1) if_block1.m(li, null);
          append(li, t5);
          if (if_block2) if_block2.m(li, null);
          append(ul, t6);
        },
        p(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty & /*param*/ 1 && t0_value !== (t0_value = /*propKey*/ ctx[8] + "")) set_data(t0, t0_value);
          if (dirty & /*param*/ 1 && t2_value !== (t2_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].type + "")) set_data(t2, t2_value);

          if (dirty & /*param*/ 1) {
            toggle_class(div, "required", /*param*/ ctx[0].schema.required && /*param*/ ctx[0].schema.required.find(func));
          }

          if (/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].description) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_5$1(ctx);
              if_block0.c();
              if_block0.m(li, t4);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          if (/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].example) {
            if (if_block1) {
              if_block1.p(ctx, dirty);
            } else {
              if_block1 = create_if_block_4$1(ctx);
              if_block1.c();
              if_block1.m(li, t5);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }

          if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block2) {
            if_block2.p(ctx, dirty);
          } else {
            if (if_block2) if_block2.d(1);
            if_block2 = current_block_type && current_block_type(ctx);

            if (if_block2) {
              if_block2.c();
              if_block2.m(li, null);
            }
          }
        },
        d(detaching) {
          if (detaching) detach(ul);
          if (if_block0) if_block0.d();
          if (if_block1) if_block1.d();

          if (if_block2) {
            if_block2.d();
          }
        }
      };
    }

    function create_fragment$1(ctx) {
      let row;
      let t;
      let div;
      let current;

      row = new Row({
        props: {
          $$slots: { default: [create_default_slot$1] },
          $$scope: { ctx }
        }
      });

      function select_block_type(ctx, dirty) {
        if (/*param*/ ctx[0].schema && /*param*/ ctx[0].keys) return create_if_block$1;
        return create_else_block$1;
      }

      let current_block_type = select_block_type(ctx);
      let if_block = current_block_type(ctx);

      return {
        c() {
          create_component(row.$$.fragment);
          t = space();
          div = element("div");
          if_block.c();
          attr(div, "class", "svelte-qzpchp");
          toggle_class(div, "jsonKeys", /*hideJsonKeys*/ ctx[1]);
        },
        m(target, anchor) {
          mount_component(row, target, anchor);
          insert(target, t, anchor);
          insert(target, div, anchor);
          if_block.m(div, null);
          current = true;
        },
        p(ctx, [dirty]) {
          const row_changes = {};

          if (dirty & /*$$scope, param, label, hideJsonKeys*/ 131079) {
            row_changes.$$scope = { dirty, ctx };
          }

          row.$set(row_changes);

          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(div, null);
            }
          }

          if (dirty & /*hideJsonKeys*/ 2) {
            toggle_class(div, "jsonKeys", /*hideJsonKeys*/ ctx[1]);
          }
        },
        i(local) {
          if (current) return;
          transition_in(row.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(row.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(row, detaching);
          if (detaching) detach(t);
          if (detaching) detach(div);
          if_block.d();
        }
      };
    }

    function instance$1($$self, $$props, $$invalidate) {
      let { param } = $$props;

      const setJsonKeys = (param, option) => {
        const required = [];
        const notRequired = [];
        const exists = [];
        const propKeys = Object.keys(param.schema.properties);
        let fieldValue = window.$("#node-input-" + param.id).typedInput("value");

        try {
          fieldValue = JSON.parse(fieldValue);
        } catch {
          fieldValue = {};
        }

        propKeys.forEach(prop => {
          if (fieldValue[prop]) {
            const value = fieldValue[prop];

            // chk if value is empty array or object -> would return "" otherwise
            if (typeof value === "object") {
              if (Array.isArray(value) && value.length === 0) exists.push(`"${prop}": []`); else if (Object.keys(value).length === 0) exists.push(`"${prop}": {}`); else exists.push(`"${prop}": "${value}"`);
            } else {
              exists.push(`"${prop}": "${value}"`);
            }
          } else {
            let isRequired = false;
            if (param.schema.required) isRequired = param.schema.required.find(reqParam => reqParam === prop);

            if (isRequired) {
              required.push(`"${prop}": "${param.schema.properties[prop].type} - required"`);
            } else {
              notRequired.push(`"${prop}": "${param.schema.properties[prop].type}"`);
            }
          }
        });

        let result = required.concat(exists);
        if (option === "default") result = result.concat(notRequired);
        result = "{" + result.join(", ") + "}";

        // jQuery because setting node.parameters[index].value does not work
        window.$("#node-input-" + param.id).typedInput("value", result);
      };

      let hideJsonKeys = true;
      let label = "Show Keys";
      const click_handler = () => $$invalidate(1, hideJsonKeys = !hideJsonKeys);
      const click_handler_1 = () => setJsonKeys(param, "default");
      const click_handler_2 = () => setJsonKeys(param, "required");
      const func = (propKey, reqParam) => reqParam === propKey;

      $$self.$$set = $$props => {
        if ("param" in $$props) $$invalidate(0, param = $$props.param);
      };

      $$self.$$.update = () => {
        if ($$self.$$.dirty & /*hideJsonKeys*/ 2) {
          if (hideJsonKeys) {
            $$invalidate(2, label = "Show Keys");
          } else {
            $$invalidate(2, label = "Hide Keys");
          }
        }
      };

      return [
        param,
        hideJsonKeys,
        label,
        setJsonKeys,
        click_handler,
        click_handler_1,
        click_handler_2,
        func
      ];
    }

    class JsonParamHelper extends SvelteComponent {
      constructor(options) {
        super();
        if (!document.getElementById("svelte-qzpchp-style")) add_css$1();
        init(this, options, instance$1, create_fragment$1, safe_not_equal, { param: 0 });
      }
    }

    /* openApi-red.svelte generated by Svelte v3.35.0 */

    function add_css() {
      var style = element("style");
      style.id = "svelte-1sy3m14-style";
      style.textContent = "#openApi-red .required, #openApi-red .required label{font-weight:bold!important}#openApi-red .label{width:104px}#openApi-red .parameterInput label{width:17px !important}#openApi-red #node-input-openApiUrl{width:70%\n  }#openApi-red .red-ui-editableList-item-content div{margin-top:0px !important;margin-bottom:0px !important}#openApi-red .red-ui-editableList-container{min-height:300px;height:100% !important;overflow-y:hidden !important}#openApi-red .red-ui-editableList .red-ui-typedInput-container{width:90% !important}#openApi-red .nodeError{color:red}";
      append(document.head, style);
    }

    function get_each_context(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[23] = list[i];
      return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[26] = list[i][0];
      return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[29] = list[i];
      return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[32] = list[i];
      return child_ctx;
    }

// (194:4) {#each errorHandlingOptions as eOption}
    function create_each_block_3(ctx) {
      let option;
      let t_value = /*eOption*/ ctx[32] + "";
      let t;

      return {
        c() {
          option = element("option");
          t = text(t_value);
          option.__value = /*eOption*/ ctx[32];
          option.value = option.__value;
        },
        m(target, anchor) {
          insert(target, option, anchor);
          append(option, t);
        },
        p: noop,
        d(detaching) {
          if (detaching) detach(option);
        }
      };
    }

// (193:2) <Select bind:node prop='errorHandling' >
    function create_default_slot_4(ctx) {
      let each_1_anchor;
      let each_value_3 = /*errorHandlingOptions*/ ctx[7];
      let each_blocks = [];

      for (let i = 0; i < each_value_3.length; i += 1) {
        each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
      }

      return {
        c() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          each_1_anchor = empty();
        },
        m(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(target, anchor);
          }

          insert(target, each_1_anchor, anchor);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*errorHandlingOptions*/ 128) {
            each_value_3 = /*errorHandlingOptions*/ ctx[7];
            let i;

            for (i = 0; i < each_value_3.length; i += 1) {
              const child_ctx = get_each_context_3(ctx, each_value_3, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block_3(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value_3.length;
          }
        },
        d(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching) detach(each_1_anchor);
        }
      };
    }

// (205:8) {:else}
    function create_else_block_3(ctx) {
      let option;
      let t_value = /*api*/ ctx[29] + "";
      let t;
      let option_value_value;

      return {
        c() {
          option = element("option");
          t = text(t_value);
          option.__value = option_value_value = /*api*/ ctx[29];
          option.value = option.__value;
        },
        m(target, anchor) {
          insert(target, option, anchor);
          append(option, t);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*apis*/ 8 && t_value !== (t_value = /*api*/ ctx[29] + "")) set_data(t, t_value);

          if (dirty[0] & /*apis*/ 8 && option_value_value !== (option_value_value = /*api*/ ctx[29])) {
            option.__value = option_value_value;
            option.value = option.__value;
          }
        },
        d(detaching) {
          if (detaching) detach(option);
        }
      };
    }

// (203:8) {#if node.api === api}
    function create_if_block_5(ctx) {
      let option;
      let t_value = /*api*/ ctx[29] + "";
      let t;
      let option_value_value;

      return {
        c() {
          option = element("option");
          t = text(t_value);
          option.__value = option_value_value = /*api*/ ctx[29];
          option.value = option.__value;
          option.selected = true;
        },
        m(target, anchor) {
          insert(target, option, anchor);
          append(option, t);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*apis*/ 8 && t_value !== (t_value = /*api*/ ctx[29] + "")) set_data(t, t_value);

          if (dirty[0] & /*apis*/ 8 && option_value_value !== (option_value_value = /*api*/ ctx[29])) {
            option.__value = option_value_value;
            option.value = option.__value;
          }
        },
        d(detaching) {
          if (detaching) detach(option);
        }
      };
    }

// (202:6) { #each apis as api}
    function create_each_block_2(ctx) {
      let if_block_anchor;

      function select_block_type(ctx, dirty) {
        if (/*node*/ ctx[0].api === /*api*/ ctx[29]) return create_if_block_5;
        return create_else_block_3;
      }

      let current_block_type = select_block_type(ctx);
      let if_block = current_block_type(ctx);

      return {
        c() {
          if_block.c();
          if_block_anchor = empty();
        },
        m(target, anchor) {
          if_block.m(target, anchor);
          insert(target, if_block_anchor, anchor);
        },
        p(ctx, dirty) {
          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          }
        },
        d(detaching) {
          if_block.d(detaching);
          if (detaching) detach(if_block_anchor);
        }
      };
    }

// (200:2) <Select bind:node prop='api' >
    function create_default_slot_3(ctx) {
      let option;
      let t;
      let each_1_anchor;
      let each_value_2 = /*apis*/ ctx[3];
      let each_blocks = [];

      for (let i = 0; i < each_value_2.length; i += 1) {
        each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
      }

      return {
        c() {
          option = element("option");
          t = space();

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          each_1_anchor = empty();
          option.__value = "";
          option.value = option.__value;
        },
        m(target, anchor) {
          insert(target, option, anchor);
          insert(target, t, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(target, anchor);
          }

          insert(target, each_1_anchor, anchor);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*apis, node*/ 9) {
            each_value_2 = /*apis*/ ctx[3];
            let i;

            for (i = 0; i < each_value_2.length; i += 1) {
              const child_ctx = get_each_context_2(ctx, each_value_2, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block_2(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value_2.length;
          }
        },
        d(detaching) {
          if (detaching) detach(option);
          if (detaching) detach(t);
          destroy_each(each_blocks, detaching);
          if (detaching) detach(each_1_anchor);
        }
      };
    }

// (216:9) {:else}
    function create_else_block_2(ctx) {
      let option;
      let t_value = /*operations*/ ctx[4][/*key*/ ctx[26]].summary + "";
      let t;
      let option_value_value;

      return {
        c() {
          option = element("option");
          t = text(t_value);
          option.__value = option_value_value = /*operations*/ ctx[4][/*key*/ ctx[26]].operationId;
          option.value = option.__value;
        },
        m(target, anchor) {
          insert(target, option, anchor);
          append(option, t);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*operations*/ 16 && t_value !== (t_value = /*operations*/ ctx[4][/*key*/ ctx[26]].summary + "")) set_data(t, t_value);

          if (dirty[0] & /*operations*/ 16 && option_value_value !== (option_value_value = /*operations*/ ctx[4][/*key*/ ctx[26]].operationId)) {
            option.__value = option_value_value;
            option.value = option.__value;
          }
        },
        d(detaching) {
          if (detaching) detach(option);
        }
      };
    }

// (214:9) {#if node.operation === operations[key].operationId}
    function create_if_block_4(ctx) {
      let option;
      let t_value = /*operations*/ ctx[4][/*key*/ ctx[26]].summary + "";
      let t;
      let option_value_value;

      return {
        c() {
          option = element("option");
          t = text(t_value);
          option.__value = option_value_value = /*operations*/ ctx[4][/*key*/ ctx[26]].operationId;
          option.value = option.__value;
          option.selected = true;
        },
        m(target, anchor) {
          insert(target, option, anchor);
          append(option, t);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*operations*/ 16 && t_value !== (t_value = /*operations*/ ctx[4][/*key*/ ctx[26]].summary + "")) set_data(t, t_value);

          if (dirty[0] & /*operations*/ 16 && option_value_value !== (option_value_value = /*operations*/ ctx[4][/*key*/ ctx[26]].operationId)) {
            option.__value = option_value_value;
            option.value = option.__value;
          }
        },
        d(detaching) {
          if (detaching) detach(option);
        }
      };
    }

// (213:7) {#each Object.entries(operations) as [key]}
    function create_each_block_1(ctx) {
      let if_block_anchor;

      function select_block_type_1(ctx, dirty) {
        if (/*node*/ ctx[0].operation === /*operations*/ ctx[4][/*key*/ ctx[26]].operationId) return create_if_block_4;
        return create_else_block_2;
      }

      let current_block_type = select_block_type_1(ctx);
      let if_block = current_block_type(ctx);

      return {
        c() {
          if_block.c();
          if_block_anchor = empty();
        },
        m(target, anchor) {
          if_block.m(target, anchor);
          insert(target, if_block_anchor, anchor);
        },
        p(ctx, dirty) {
          if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          }
        },
        d(detaching) {
          if_block.d(detaching);
          if (detaching) detach(if_block_anchor);
        }
      };
    }

// (211:3) <Select bind:node prop='operation' inline>
    function create_default_slot_2(ctx) {
      let option;
      let t;
      let each_1_anchor;
      let each_value_1 = Object.entries(/*operations*/ ctx[4]);
      let each_blocks = [];

      for (let i = 0; i < each_value_1.length; i += 1) {
        each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
      }

      return {
        c() {
          option = element("option");
          t = space();

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          each_1_anchor = empty();
          option.__value = "";
          option.value = option.__value;
        },
        m(target, anchor) {
          insert(target, option, anchor);
          insert(target, t, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(target, anchor);
          }

          insert(target, each_1_anchor, anchor);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*operations, node*/ 17) {
            each_value_1 = Object.entries(/*operations*/ ctx[4]);
            let i;

            for (i = 0; i < each_value_1.length; i += 1) {
              const child_ctx = get_each_context_1(ctx, each_value_1, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block_1(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value_1.length;
          }
        },
        d(detaching) {
          if (detaching) detach(option);
          if (detaching) detach(t);
          destroy_each(each_blocks, detaching);
          if (detaching) detach(each_1_anchor);
        }
      };
    }

// (221:3) {#if {operationDescription} }
    function create_if_block_3(ctx) {
      let div2;
      let div0;
      let t1;
      let div1;
      let t2;

      return {
        c() {
          div2 = element("div");
          div0 = element("div");
          div0.textContent = "Description";
          t1 = space();
          div1 = element("div");
          t2 = text(/*operationDescription*/ ctx[5]);
          attr(div0, "class", "label");
          set_style(div1, "width", "70%");
          set_style(div2, "display", "flex");
          set_style(div2, "margin-bottom", "12px");
        },
        m(target, anchor) {
          insert(target, div2, anchor);
          append(div2, div0);
          append(div2, t1);
          append(div2, div1);
          append(div1, t2);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*operationDescription*/ 32) set_data(t2, /*operationDescription*/ ctx[5]);
        },
        d(detaching) {
          if (detaching) detach(div2);
        }
      };
    }

// (233:5) {:else}
    function create_else_block_1(ctx) {
      let option;
      let t_value = /*contentType*/ ctx[23] + "";
      let t;
      let option_value_value;

      return {
        c() {
          option = element("option");
          t = text(t_value);
          option.__value = option_value_value = /*contentType*/ ctx[23];
          option.value = option.__value;
        },
        m(target, anchor) {
          insert(target, option, anchor);
          append(option, t);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*contentTypes*/ 2 && t_value !== (t_value = /*contentType*/ ctx[23] + "")) set_data(t, t_value);

          if (dirty[0] & /*contentTypes*/ 2 && option_value_value !== (option_value_value = /*contentType*/ ctx[23])) {
            option.__value = option_value_value;
            option.value = option.__value;
          }
        },
        d(detaching) {
          if (detaching) detach(option);
        }
      };
    }

// (231:5) {#if node.contentType === contentType}
    function create_if_block_2(ctx) {
      let option;
      let t_value = /*contentType*/ ctx[23] + "";
      let t;
      let option_value_value;

      return {
        c() {
          option = element("option");
          t = text(t_value);
          option.__value = option_value_value = /*contentType*/ ctx[23];
          option.value = option.__value;
          option.selected = true;
        },
        m(target, anchor) {
          insert(target, option, anchor);
          append(option, t);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*contentTypes*/ 2 && t_value !== (t_value = /*contentType*/ ctx[23] + "")) set_data(t, t_value);

          if (dirty[0] & /*contentTypes*/ 2 && option_value_value !== (option_value_value = /*contentType*/ ctx[23])) {
            option.__value = option_value_value;
            option.value = option.__value;
          }
        },
        d(detaching) {
          if (detaching) detach(option);
        }
      };
    }

// (230:4) {#each contentTypes as contentType}
    function create_each_block(ctx) {
      let if_block_anchor;

      function select_block_type_2(ctx, dirty) {
        if (/*node*/ ctx[0].contentType === /*contentType*/ ctx[23]) return create_if_block_2;
        return create_else_block_1;
      }

      let current_block_type = select_block_type_2(ctx);
      let if_block = current_block_type(ctx);

      return {
        c() {
          if_block.c();
          if_block_anchor = empty();
        },
        m(target, anchor) {
          if_block.m(target, anchor);
          insert(target, if_block_anchor, anchor);
        },
        p(ctx, dirty) {
          if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          }
        },
        d(detaching) {
          if_block.d(detaching);
          if (detaching) detach(if_block_anchor);
        }
      };
    }

// (229:2) <Select bind:node prop='contentType'>
    function create_default_slot_1(ctx) {
      let each_1_anchor;
      let each_value = /*contentTypes*/ ctx[1];
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
      }

      return {
        c() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          each_1_anchor = empty();
        },
        m(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(target, anchor);
          }

          insert(target, each_1_anchor, anchor);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*contentTypes, node*/ 3) {
            each_value = /*contentTypes*/ ctx[1];
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }
        },
        d(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching) detach(each_1_anchor);
        }
      };
    }

// (272:2) {:else}
    function create_else_block(ctx) {
      let div;

      return {
        c() {
          div = element("div");
          div.textContent = "No parameters found!";
          set_style(div, "margin-top", "30px");
          set_style(div, "font-weight", "bold");
        },
        m(target, anchor) {
          insert(target, div, anchor);
        },
        p: noop,
        i: noop,
        o: noop,
        d(detaching) {
          if (detaching) detach(div);
        }
      };
    }

// (242:2) {#if node.parameters.length > 0}
    function create_if_block(ctx) {
      let editablelist;
      let updating_elements;
      let current;

      function editablelist_elements_binding(value) {
        /*editablelist_elements_binding*/ ctx[18](value);
      }

      let editablelist_props = {
        $$slots: {
          default: [
            create_default_slot,
            ({ element: param, index }) => ({ 21: param, 22: index }),
            ({ element: param, index }) => [(param ? 2097152 : 0) | (index ? 4194304 : 0)]
          ]
        },
        $$scope: { ctx }
      };

      if (/*node*/ ctx[0].parameters !== void 0) {
        editablelist_props.elements = /*node*/ ctx[0].parameters;
      }

      editablelist = new EditableList({ props: editablelist_props });
      binding_callbacks.push(() => bind(editablelist, "elements", editablelist_elements_binding));

      return {
        c() {
          create_component(editablelist.$$.fragment);
        },
        m(target, anchor) {
          mount_component(editablelist, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          const editablelist_changes = {};

          if (dirty[0] & /*param, node*/ 2097153 | dirty[1] & /*$$scope*/ 16) {
            editablelist_changes.$$scope = { dirty, ctx };
          }

          if (!updating_elements && dirty[0] & /*node*/ 1) {
            updating_elements = true;
            editablelist_changes.elements = /*node*/ ctx[0].parameters;
            add_flush_callback(() => updating_elements = false);
          }

          editablelist.$set(editablelist_changes);
        },
        i(local) {
          if (current) return;
          transition_in(editablelist.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(editablelist.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(editablelist, detaching);
        }
      };
    }

// (266:4) {#if param?.schema?.type === 'object'}
    function create_if_block_1(ctx) {
      let div;
      let jsonparamhelper;
      let current;
      jsonparamhelper = new JsonParamHelper({ props: { param: /*param*/ ctx[21] } });

      return {
        c() {
          div = element("div");
          create_component(jsonparamhelper.$$.fragment);
          set_style(div, "margin-left", "20px");
          set_style(div, "margin-top", "10px", 1);
        },
        m(target, anchor) {
          insert(target, div, anchor);
          mount_component(jsonparamhelper, div, null);
          current = true;
        },
        p(ctx, dirty) {
          const jsonparamhelper_changes = {};
          if (dirty[0] & /*param*/ 2097152) jsonparamhelper_changes.param = /*param*/ ctx[21];
          jsonparamhelper.$set(jsonparamhelper_changes);
        },
        i(local) {
          if (current) return;
          transition_in(jsonparamhelper.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(jsonparamhelper.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          if (detaching) detach(div);
          destroy_component(jsonparamhelper);
        }
      };
    }

// (243:2) <EditableList bind:elements={node.parameters} let:element={param} let:index>
    function create_default_slot(ctx) {
      let div1;
      let div0;
      let input;
      let t0;
      let div2;
      let typedinput;
      let t1;
      let if_block_anchor;
      let current;

      function change_handler(...args) {
        return /*change_handler*/ ctx[16](/*index*/ ctx[22], ...args);
      }

      input = new Input({
        props: {
          type: "checkbox",
          label: /*param*/ ctx[21].name + ": " + /*param*/ ctx[21].description,
          value: /*param*/ ctx[21].isActive,
          disabled: /*param*/ ctx[21].required
        }
      });

      input.$on("change", change_handler);

      function change_handler_1(...args) {
        return /*change_handler_1*/ ctx[17](/*index*/ ctx[22], /*param*/ ctx[21], ...args);
      }

      typedinput = new TypedInput({
        props: {
          label: " ",
          types: /*param*/ ctx[21].allowedTypes,
          type: /*param*/ ctx[21].type,
          value: /*param*/ ctx[21].value,
          id: /*param*/ ctx[21].id,
          disabled: !/*param*/ ctx[21].isActive
        }
      });

      typedinput.$on("change", change_handler_1);
      let if_block = /*param*/ ctx[21]?.schema?.type === "object" && create_if_block_1(ctx);

      return {
        c() {
          div1 = element("div");
          div0 = element("div");
          create_component(input.$$.fragment);
          t0 = space();
          div2 = element("div");
          create_component(typedinput.$$.fragment);
          t1 = space();
          if (if_block) if_block.c();
          if_block_anchor = empty();
          set_style(div0, "min-width", "99px");
          set_style(div1, "display", "flex");
          toggle_class(div1, "required", /*param*/ ctx[21].required);
          attr(div2, "class", "parameterInput");
        },
        m(target, anchor) {
          insert(target, div1, anchor);
          append(div1, div0);
          mount_component(input, div0, null);
          insert(target, t0, anchor);
          insert(target, div2, anchor);
          mount_component(typedinput, div2, null);
          insert(target, t1, anchor);
          if (if_block) if_block.m(target, anchor);
          insert(target, if_block_anchor, anchor);
          current = true;
        },
        p(new_ctx, dirty) {
          ctx = new_ctx;
          const input_changes = {};
          if (dirty[0] & /*param*/ 2097152) input_changes.label = /*param*/ ctx[21].name + ": " + /*param*/ ctx[21].description;
          if (dirty[0] & /*param*/ 2097152) input_changes.value = /*param*/ ctx[21].isActive;
          if (dirty[0] & /*param*/ 2097152) input_changes.disabled = /*param*/ ctx[21].required;
          input.$set(input_changes);

          if (dirty[0] & /*param*/ 2097152) {
            toggle_class(div1, "required", /*param*/ ctx[21].required);
          }

          const typedinput_changes = {};
          if (dirty[0] & /*param*/ 2097152) typedinput_changes.types = /*param*/ ctx[21].allowedTypes;
          if (dirty[0] & /*param*/ 2097152) typedinput_changes.type = /*param*/ ctx[21].type;
          if (dirty[0] & /*param*/ 2097152) typedinput_changes.value = /*param*/ ctx[21].value;
          if (dirty[0] & /*param*/ 2097152) typedinput_changes.id = /*param*/ ctx[21].id;
          if (dirty[0] & /*param*/ 2097152) typedinput_changes.disabled = !/*param*/ ctx[21].isActive;
          typedinput.$set(typedinput_changes);

          if (/*param*/ ctx[21]?.schema?.type === "object") {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty[0] & /*param*/ 2097152) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block_1(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();

            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });

            check_outros();
          }
        },
        i(local) {
          if (current) return;
          transition_in(input.$$.fragment, local);
          transition_in(typedinput.$$.fragment, local);
          transition_in(if_block);
          current = true;
        },
        o(local) {
          transition_out(input.$$.fragment, local);
          transition_out(typedinput.$$.fragment, local);
          transition_out(if_block);
          current = false;
        },
        d(detaching) {
          if (detaching) detach(div1);
          destroy_component(input);
          if (detaching) detach(t0);
          if (detaching) detach(div2);
          destroy_component(typedinput);
          if (detaching) detach(t1);
          if (if_block) if_block.d(detaching);
          if (detaching) detach(if_block_anchor);
        }
      };
    }

    function create_fragment(ctx) {
      let div6;
      let input0;
      let updating_node;
      let t0;
      let div2;
      let div0;
      let t2;
      let div1;
      let input1;
      let updating_node_1;
      let t3;
      let button;
      let t4;
      let select0;
      let updating_node_2;
      let t5;
      let div3;
      let t6;
      let t7;
      let hr;
      let t8;
      let select1;
      let updating_node_3;
      let t9;
      let div4;
      let select2;
      let updating_node_4;
      let t10;
      let t11;
      let select3;
      let updating_node_5;
      let t12;
      let div5;
      let t16;
      let current_block_type_index;
      let if_block1;
      let current;

      function input0_node_binding(value) {
        /*input0_node_binding*/ ctx[10](value);
      }

      let input0_props = { prop: "name", placeholder: "openApi-red" };

      if (/*node*/ ctx[0] !== void 0) {
        input0_props.node = /*node*/ ctx[0];
      }

      input0 = new Input({ props: input0_props });
      binding_callbacks.push(() => bind(input0, "node", input0_node_binding));

      function input1_node_binding(value) {
        /*input1_node_binding*/ ctx[11](value);
      }

      let input1_props = {
        prop: "openApiUrl",
        label: " ",
        inline: true
      };

      if (/*node*/ ctx[0] !== void 0) {
        input1_props.node = /*node*/ ctx[0];
      }

      input1 = new Input({ props: input1_props });
      binding_callbacks.push(() => bind(input1, "node", input1_node_binding));

      button = new Button({
        props: {
          icon: "edit",
          label: "read",
          inline: true
        }
      });

      button.$on("click", /*createApi*/ ctx[6]);

      function select0_node_binding(value) {
        /*select0_node_binding*/ ctx[12](value);
      }

      let select0_props = {
        prop: "errorHandling",
        $$slots: { default: [create_default_slot_4] },
        $$scope: { ctx }
      };

      if (/*node*/ ctx[0] !== void 0) {
        select0_props.node = /*node*/ ctx[0];
      }

      select0 = new Select({ props: select0_props });
      binding_callbacks.push(() => bind(select0, "node", select0_node_binding));

      function select1_node_binding(value) {
        /*select1_node_binding*/ ctx[13](value);
      }

      let select1_props = {
        prop: "api",
        $$slots: { default: [create_default_slot_3] },
        $$scope: { ctx }
      };

      if (/*node*/ ctx[0] !== void 0) {
        select1_props.node = /*node*/ ctx[0];
      }

      select1 = new Select({ props: select1_props });
      binding_callbacks.push(() => bind(select1, "node", select1_node_binding));

      function select2_node_binding(value) {
        /*select2_node_binding*/ ctx[14](value);
      }

      let select2_props = {
        prop: "operation",
        inline: true,
        $$slots: { default: [create_default_slot_2] },
        $$scope: { ctx }
      };

      if (/*node*/ ctx[0] !== void 0) {
        select2_props.node = /*node*/ ctx[0];
      }

      select2 = new Select({ props: select2_props });
      binding_callbacks.push(() => bind(select2, "node", select2_node_binding));

      let if_block0 = {
        operationDescription: /*operationDescription*/ ctx[5]
      } && create_if_block_3(ctx);

      function select3_node_binding(value) {
        /*select3_node_binding*/ ctx[15](value);
      }

      let select3_props = {
        prop: "contentType",
        $$slots: { default: [create_default_slot_1] },
        $$scope: { ctx }
      };

      if (/*node*/ ctx[0] !== void 0) {
        select3_props.node = /*node*/ ctx[0];
      }

      select3 = new Select({ props: select3_props });
      binding_callbacks.push(() => bind(select3, "node", select3_node_binding));
      const if_block_creators = [create_if_block, create_else_block];
      const if_blocks = [];

      function select_block_type_3(ctx, dirty) {
        if (/*node*/ ctx[0].parameters.length > 0) return 0;
        return 1;
      }

      current_block_type_index = select_block_type_3(ctx);
      if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

      return {
        c() {
          div6 = element("div");
          create_component(input0.$$.fragment);
          t0 = space();
          div2 = element("div");
          div0 = element("div");
          div0.innerHTML = `<label class="label" for="node-input-openApiUrl">URL</label>`;
          t2 = space();
          div1 = element("div");
          create_component(input1.$$.fragment);
          t3 = space();
          create_component(button.$$.fragment);
          t4 = space();
          create_component(select0.$$.fragment);
          t5 = space();
          div3 = element("div");
          t6 = text(/*error*/ ctx[2]);
          t7 = space();
          hr = element("hr");
          t8 = space();
          create_component(select1.$$.fragment);
          t9 = space();
          div4 = element("div");
          create_component(select2.$$.fragment);
          t10 = space();
          if (if_block0) if_block0.c();
          t11 = space();
          create_component(select3.$$.fragment);
          t12 = space();
          div5 = element("div");

          div5.innerHTML = `<span class="label">Parameters</span>
    <span style="font-size: 10px;">(bold = required parameters)</span>`;

          t16 = space();
          if_block1.c();
          set_style(div1, "width", "100%");
          set_style(div2, "display", "flex");
          set_style(div2, "align-items", "baseline");
          set_style(div2, "margin-top", "-7px");
          set_style(div2, "margin-bottom", "10px");
          attr(div3, "class", "nodeError");
          set_style(div5, "display", "flex");
          attr(div6, "id", "openApi-red");
        },
        m(target, anchor) {
          insert(target, div6, anchor);
          mount_component(input0, div6, null);
          append(div6, t0);
          append(div6, div2);
          append(div2, div0);
          append(div2, t2);
          append(div2, div1);
          mount_component(input1, div1, null);
          append(div1, t3);
          mount_component(button, div1, null);
          append(div6, t4);
          mount_component(select0, div6, null);
          append(div6, t5);
          append(div6, div3);
          append(div3, t6);
          append(div6, t7);
          append(div6, hr);
          append(div6, t8);
          mount_component(select1, div6, null);
          append(div6, t9);
          append(div6, div4);
          mount_component(select2, div4, null);
          append(div4, t10);
          if (if_block0) if_block0.m(div4, null);
          append(div6, t11);
          mount_component(select3, div6, null);
          append(div6, t12);
          append(div6, div5);
          append(div6, t16);
          if_blocks[current_block_type_index].m(div6, null);
          current = true;
        },
        p(ctx, dirty) {
          const input0_changes = {};

          if (!updating_node && dirty[0] & /*node*/ 1) {
            updating_node = true;
            input0_changes.node = /*node*/ ctx[0];
            add_flush_callback(() => updating_node = false);
          }

          input0.$set(input0_changes);
          const input1_changes = {};

          if (!updating_node_1 && dirty[0] & /*node*/ 1) {
            updating_node_1 = true;
            input1_changes.node = /*node*/ ctx[0];
            add_flush_callback(() => updating_node_1 = false);
          }

          input1.$set(input1_changes);
          const select0_changes = {};

          if (dirty[1] & /*$$scope*/ 16) {
            select0_changes.$$scope = { dirty, ctx };
          }

          if (!updating_node_2 && dirty[0] & /*node*/ 1) {
            updating_node_2 = true;
            select0_changes.node = /*node*/ ctx[0];
            add_flush_callback(() => updating_node_2 = false);
          }

          select0.$set(select0_changes);
          if (!current || dirty[0] & /*error*/ 4) set_data(t6, /*error*/ ctx[2]);
          const select1_changes = {};

          if (dirty[0] & /*apis, node*/ 9 | dirty[1] & /*$$scope*/ 16) {
            select1_changes.$$scope = { dirty, ctx };
          }

          if (!updating_node_3 && dirty[0] & /*node*/ 1) {
            updating_node_3 = true;
            select1_changes.node = /*node*/ ctx[0];
            add_flush_callback(() => updating_node_3 = false);
          }

          select1.$set(select1_changes);
          const select2_changes = {};

          if (dirty[0] & /*operations, node*/ 17 | dirty[1] & /*$$scope*/ 16) {
            select2_changes.$$scope = { dirty, ctx };
          }

          if (!updating_node_4 && dirty[0] & /*node*/ 1) {
            updating_node_4 = true;
            select2_changes.node = /*node*/ ctx[0];
            add_flush_callback(() => updating_node_4 = false);
          }

          select2.$set(select2_changes);

          if ({
            operationDescription: /*operationDescription*/ ctx[5]
          }) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_3(ctx);
              if_block0.c();
              if_block0.m(div4, null);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          const select3_changes = {};

          if (dirty[0] & /*contentTypes, node*/ 3 | dirty[1] & /*$$scope*/ 16) {
            select3_changes.$$scope = { dirty, ctx };
          }

          if (!updating_node_5 && dirty[0] & /*node*/ 1) {
            updating_node_5 = true;
            select3_changes.node = /*node*/ ctx[0];
            add_flush_callback(() => updating_node_5 = false);
          }

          select3.$set(select3_changes);
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type_3(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();

            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });

            check_outros();
            if_block1 = if_blocks[current_block_type_index];

            if (!if_block1) {
              if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block1.c();
            } else {
              if_block1.p(ctx, dirty);
            }

            transition_in(if_block1, 1);
            if_block1.m(div6, null);
          }
        },
        i(local) {
          if (current) return;
          transition_in(input0.$$.fragment, local);
          transition_in(input1.$$.fragment, local);
          transition_in(button.$$.fragment, local);
          transition_in(select0.$$.fragment, local);
          transition_in(select1.$$.fragment, local);
          transition_in(select2.$$.fragment, local);
          transition_in(select3.$$.fragment, local);
          transition_in(if_block1);
          current = true;
        },
        o(local) {
          transition_out(input0.$$.fragment, local);
          transition_out(input1.$$.fragment, local);
          transition_out(button.$$.fragment, local);
          transition_out(select0.$$.fragment, local);
          transition_out(select1.$$.fragment, local);
          transition_out(select2.$$.fragment, local);
          transition_out(select3.$$.fragment, local);
          transition_out(if_block1);
          current = false;
        },
        d(detaching) {
          if (detaching) detach(div6);
          destroy_component(input0);
          destroy_component(input1);
          destroy_component(button);
          destroy_component(select0);
          destroy_component(select1);
          destroy_component(select2);
          if (if_block0) if_block0.d();
          destroy_component(select3);
          if_blocks[current_block_type_index].d();
        }
      };
    }

    RED.nodes.registerType("openapi-client", {
      category: "network",
      color: "#b197ff",
      defaults: {
        name: { value: "", label: "Name" },
        openApiUrl: { value: "", label: "URL" },
        api: { value: "", label: "API tag" },
        operation: { value: "", label: "Operation" },
        operationData: { value: {} },
        errorHandling: { value: "", label: "Error handling" },
        parameters: {
          value: [],
          label: "Parameters",
          validate(parameters) {
            if (!parameters || !Array.isArray(parameters) || parameters.length === 0) {
              return true;
            } else {
              let isValid = true;

              parameters.forEach(p => {
                if (isValid && p.isActive) {
                  if (p.required && p.value.trim() === "") isValid = false;

                  // validation of typedinput only if element exists!
                  if (isValid && window.$("#node-input-" + p.id).length) isValid = window.$("#node-input-" + p.id).typedInput("validate");
                }
              });

              return isValid;
            }
          }
        },
        contentType: { value: "", label: "Content Type" },
        outputs: { value: 1 }
      },
      inputs: 1,
      outputs: 1,
      icon: "white-globe.png",
      label() {
        if (this.name) return this.name; else if (this.operation) return this.operation; else return "openApi client";
      },
      oneditprepare() {
        render(this);
      },
      oneditsave() {
        let clone = this.__clone;

        // Bugfix SIR? if name is empty it returns undefined which will make the node think it has changed
        if (typeof clone.name === "undefined") clone.name = "";

        // Workaround if JSON-Editor (ACE) was used -> more info in bottom code (on:change event for typedInput Parameters)
        if (clone.saveTypedInputAgain) {
          clone.saveTypedInputAgain.forEach(({ index, id }) => {
            clone.parameters[index].value = window.$("#node-input-" + id).typedInput("value");
          });
        }

        update(this);
      },
      oneditcancel() {
        revert(this);
      }
    });

    function instance($$self, $$props, $$invalidate) {
      let { node } = $$props;
      let apiList = {};
      let error = "";
      let apis = [];
      let operations = {};
      let operationDescription = "-";
      let prevOperation;
      if (node.operation) prevOperation = node.operation.toString();
      node.saveTypedInputAgain = [];
      let contentTypes = [];
      let oldParameters = {};

      const setError = message => {
        $$invalidate(3, apis = []);
        $$invalidate(4, operations = {});
        $$invalidate(1, contentTypes = []);
        $$invalidate(2, error = message);
        return;
      };

      const createApi = async () => {
        try {
          $$invalidate(2, error = "");
          $$invalidate(8, apiList = await getApiList(node.openApiUrl));

          // save old parameter objects (openApi-red version <0.2) - changed from object to array objects
          if (!Array.isArray(node.parameters) && node.api && node.operation) {
            Object.assign(oldParameters, node.parameters);
            $$invalidate(0, node.parameters = [], node);
            $$invalidate(9, prevOperation = "");
            $$invalidate(0, node.operationData = apiList?.[node.api]?.[node.operation], node);
          }

          // if a string was returned it is a node error
          if (typeof apiList === "string") {
            setError(apiList);
          } else {
            $$invalidate(3, apis = Object.keys(apiList));
          }
        } catch(e) {
          setError(e);
        }
      };

      if (node.openApiUrl.toString().trim()) createApi();
      const errorHandlingOptions = ["Standard", "other output", "throw exception"];

      function input0_node_binding(value) {
        node = value;
        (((($$invalidate(0, node), $$invalidate(8, apiList)), $$invalidate(1, contentTypes)), $$invalidate(9, prevOperation)), $$invalidate(19, oldParameters));
      }

      function input1_node_binding(value) {
        node = value;
        (((($$invalidate(0, node), $$invalidate(8, apiList)), $$invalidate(1, contentTypes)), $$invalidate(9, prevOperation)), $$invalidate(19, oldParameters));
      }

      function select0_node_binding(value) {
        node = value;
        (((($$invalidate(0, node), $$invalidate(8, apiList)), $$invalidate(1, contentTypes)), $$invalidate(9, prevOperation)), $$invalidate(19, oldParameters));
      }

      function select1_node_binding(value) {
        node = value;
        (((($$invalidate(0, node), $$invalidate(8, apiList)), $$invalidate(1, contentTypes)), $$invalidate(9, prevOperation)), $$invalidate(19, oldParameters));
      }

      function select2_node_binding(value) {
        node = value;
        (((($$invalidate(0, node), $$invalidate(8, apiList)), $$invalidate(1, contentTypes)), $$invalidate(9, prevOperation)), $$invalidate(19, oldParameters));
      }

      function select3_node_binding(value) {
        node = value;
        (((($$invalidate(0, node), $$invalidate(8, apiList)), $$invalidate(1, contentTypes)), $$invalidate(9, prevOperation)), $$invalidate(19, oldParameters));
      }

      const change_handler = (index, e) => $$invalidate(0, node.parameters[index].isActive = e.detail.value, node);

      const change_handler_1 = (index, param, e) => {
        // if JSON-Editor (ACE) is used, it will return '[object Object]' as value, but set the correct JSON in the input field.
        // This seems to be a bug which occurs to non default fields and SIR. As non default fields will not be saved automaticlly (and this is a correct behavior)
        // we must use a workaround and don't save the value with the on:change event but save it when the node will be closed.
        if (typeof e.detail.value !== "object" && e.detail.value.toString() !== "[object Object]") {
          $$invalidate(0, node.parameters[index].value = e.detail.value, node);
          $$invalidate(0, node.parameters[index].type = e.detail.type, node);
        } else {
          // within the change event window.$('#node-input-' + id).typedInput('value') would also return the wrong value
          node.saveTypedInputAgain.push({ index, "id": param.id });
        }
      };

      function editablelist_elements_binding(value) {
        if ($$self.$$.not_equal(node.parameters, value)) {
          node.parameters = value;
          (((($$invalidate(0, node), $$invalidate(8, apiList)), $$invalidate(1, contentTypes)), $$invalidate(9, prevOperation)), $$invalidate(19, oldParameters));
        }
      }

      $$self.$$set = $$props => {
        if ("node" in $$props) $$invalidate(0, node = $$props.node);
      };

      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & /*node, apiList*/ 257) {
          // set valid operations if api is set
          if (node.api && apiList?.[node.api]) {
            $$invalidate(4, operations = apiList[node.api]);
            (((($$invalidate(0, node), $$invalidate(8, apiList)), $$invalidate(1, contentTypes)), $$invalidate(9, prevOperation)), $$invalidate(19, oldParameters));
          } else {
            $$invalidate(4, operations = {});
          }
        }

        if ($$self.$$.dirty[0] & /*node, apiList, contentTypes, prevOperation*/ 771) {
          // create content type selection and parameter list
          if (node.operation) {
            $$invalidate(5, operationDescription = "-");

            if (apiList?.[node.api]?.[node.operation]?.description) {
              $$invalidate(5, operationDescription = apiList[node.api][node.operation].description);
            }

            // set valid content Types if operation is set
            if (apiList?.[node.api]?.[node.operation]?.requestBody?.content) {
              $$invalidate(1, contentTypes = Object.keys(apiList[node.api][node.operation].requestBody.content));
            } else {
              // needed input since an update from swagger.js
              $$invalidate(1, contentTypes = [
                "application/json",
                "application/x-www-form-urlencoded",
                "multipart/form-data"
              ]);
            }

            if (!node.contentType || !contentTypes.includes(node.contentType)) {
              $$invalidate(0, node.contentType = contentTypes[0], node);
            }

            // clear parameters if operation has changed
            if (prevOperation !== node.operation) {
              node.parameters.splice(0, node.parameters.length);
              $$invalidate(9, prevOperation = node.operation);
              let operationData = apiList?.[node.api]?.[node.operation];
              if (!operationData) operationData = {};
              $$invalidate(0, node.operationData = operationData, node);
              createParameters(node, operationData, oldParameters);
            }
          }
        }

        if ($$self.$$.dirty[0] & /*node*/ 1) {
          if (node.errorHandling) {
            if ("other output" === node.errorHandling) $$invalidate(0, node.outputs = 2, node); else $$invalidate(0, node.outputs = 1, node);
          }
        }
      };

      return [
        node,
        contentTypes,
        error,
        apis,
        operations,
        operationDescription,
        createApi,
        errorHandlingOptions,
        apiList,
        prevOperation,
        input0_node_binding,
        input1_node_binding,
        select0_node_binding,
        select1_node_binding,
        select2_node_binding,
        select3_node_binding,
        change_handler,
        change_handler_1,
        editablelist_elements_binding
      ];
    }

    class OpenApi_red extends SvelteComponent {
      constructor(options) {
        super();
        if (!document.getElementById("svelte-1sy3m14-style")) add_css();
        init(this, options, instance, create_fragment, safe_not_equal, { node: 0 }, [-1, -1]);
      }
    }



  }
</script>
<script type="text/x-red" data-template-name="openapi-client">
                <div id='openApi-red-svelte-container'></div>
            </script>
<script type="text/x-red" data-help-name="openapi-client">
                <p>Use OpenAPI / Swagger with Node-Red.</p>
<h3>Inputs</h3>
    <dl class="message-properties">
        <dt>Name
            <span class="property-type">string</span>
        </dt>
        <dd> set a manuell name for the node. If no name is set, the node sets the selected operation name.</dd>
        <dt>URL
            <span class="property-type">string</span>
        </dt>
        <dd> set the full url domain name (incl. http:// / https://) for the OpenAPI document. By clicking on 'read' it will build the API and operation Selectors.</dd>
        <dt>API tag
            <span class="property-type">enum</span>
        </dt>
        <dd> Preselector for the operation. Grouped by the 'tags' in each operation. </dd>
        <dt>Operation
            <span class="property-type">enum</span>
        </dt>
        <dd> Selector for the OpenAPI operation. The selection name is set by the 'summary'. Behind the selector field is the (unique) operation id. By mouse-over it will show the full operation Description.</dd>
        <dt class="optional">Parameters <span class="property-type">depending</span></dt>
        <dd> If the selected operation has parameters, they will be listed here. The description can be found by mouse-over the parameter name. If the parameter is required, it will be marked with a red star behind the name.
            For Json Objects with defined keys there will be 3 Buttons: 'set required' and 'set default' will build a json-object with the correct key names and the necessary type info as the value. 'show keys' show all possible key parameters with additional info by mouse-over the key name.</dd>
    </dl>

    <h3>Outputs</h3>
    <dl class="message-properties">
    <dt>Payload <span class="property-type">object</span>
        <dd> Returns the complete OpenAPI object.</dd>
    </dt>
    </dl>

<h3>Authentification</h3>
    For authentification you can use the Node-Red to get your token. This token has to be set into msg.openApiToken.

<h3>Dynamic fields</h3>
For using dynamic OpenApi URL, operation or parameter put those into msg.openApiUrl (string), msg.operation (operationId as string) and msg.parameters (object with key as parameter name).

<h3>Error handling</h3>
This handles how to react if the server returns a http status of 4xx or 5xx. You can find the last server response in msg.response.
<dl class="message-properties">
    <dt>Standard  <span class="property-type">string</span> </dt>
    <dd> The flow will move on normally so you can choose how to handle this within your flow.</dd>
    <dt> Other output <span class="property-type">string</span></dt>
    <dd> The flow will move on in a second output.</dd>
    <dt> Throw exception <span class="property-type">string</span></dt>
    <dd> The flow will throw an exception. This exception can be catched by the 'catch' node.</dd>
</dl>

<h3>References</h3>
    <ul>
        <li><a href="https://www.npmjs.com/package/swagger-client">Based on npm swagger-client</a> - which does almost all the magic here</li>
        <li><a href="https://gitlab.com/2WeltenChris/svelte-integration-red">SIR</a> - Node designed with svelte</li>
        <li><a href="https://gitlab.com/2WeltenChris/openapi-red">GitHub</a> - the nodes github repository</li>
    </ul>

            </script>
